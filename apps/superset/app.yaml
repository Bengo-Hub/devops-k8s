apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: superset
  namespace: argocd
  annotations:
    # Deploy after databases are ready (higher sync wave = later deployment)
    argocd.argoproj.io/sync-wave: "10"
  finalizers:
    - resources-finalizer.argocd.argoproj.io
spec:
  project: default
  source:
    repoURL: https://apache.github.io/superset
    targetRevision: 0.15.0
    chart: superset
    helm:
      values: |
          # Image configuration with pinned version for stability
          image:
            repository: apache/superset
            tag: "3.1.0"
            pullPolicy: IfNotPresent
          
          # Replicas - optimized for 12-core server
          replicaCount: 1
          
          # Resource limits and requests - optimized for 12-core server
          resources:
            requests:
              cpu: 200m  # Reduced for resource efficiency
              memory: 512Mi
            limits:
              cpu: 1000m
              memory: 2Gi
          
          # Horizontal Pod Autoscaling for handling load variations
          autoscaling:
            enabled: true
            minReplicas: 1
            maxReplicas: 3
            targetCPUUtilizationPercentage: 70
            targetMemoryUtilizationPercentage: 75
          
          # Rolling update strategy to ensure zero downtime
          deploymentStrategy:
            type: RollingUpdate
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 0
          
          # Extended progress deadline for Superset's slow initialization
          progressDeadlineSeconds: 1200  # 20 minutes
          
          # Health checks - critical for proper orchestration
          livenessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 120  # Superset takes time to start
            periodSeconds: 20
            timeoutSeconds: 10
            failureThreshold: 5
            successThreshold: 1
          
          readinessProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 6
            successThreshold: 1
          
          # Startup probe to handle slow initialization
          startupProbe:
            httpGet:
              path: /health
              port: http
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 30  # 5 minutes total (30 * 10s)
            successThreshold: 1
          
          # Service configuration
          service:
            type: ClusterIP
            port: 8088
            annotations: {}
          
          # Ingress configuration
          ingress:
            enabled: true
            ingressClassName: nginx
            hosts:
              - superset.codevertexitsolutions.com
            path: /
            pathType: Prefix
            annotations:
              cert-manager.io/cluster-issuer: letsencrypt-prod
              nginx.ingress.kubernetes.io/ssl-redirect: "true"
              nginx.ingress.kubernetes.io/proxy-body-size: "50m"
              nginx.ingress.kubernetes.io/proxy-read-timeout: "300"
              nginx.ingress.kubernetes.io/proxy-send-timeout: "300"
              nginx.ingress.kubernetes.io/proxy-connect-timeout: "300"
            tls:
              - hosts:
                  - superset.codevertexitsolutions.com
                secretName: superset-codevertexitsolutions-tls
          
          # Admin user initialization and init containers for external databases
          init:
            enabled: true
            adminUser:
              username: admin
              firstname: Admin
              lastname: User
              email: admin@codevertexitsolutions.com
            # Password from secret
            envFromSecret: superset-secrets
            resources:
              requests:
                cpu: 200m
                memory: 512Mi
              limits:
                cpu: 1000m
                memory: 2Gi
            # Override default init containers to wait for external databases
            initContainers:
              - name: wait-for-postgres-redis
                image: busybox:1.36
                imagePullPolicy: IfNotPresent
                command:
                  - sh
                  - -c
                  - |
                    echo "Waiting for external PostgreSQL..."
                    until nc -z postgresql.infra.svc.cluster.local 5432; do
                      echo "PostgreSQL not ready, waiting..."
                      sleep 2
                    done
                    echo "PostgreSQL is ready!"

                    echo "Waiting for external Redis..."
                    until nc -z redis-master.infra.svc.cluster.local 6379; do
                      echo "Redis not ready, waiting..."
                      sleep 2
                    done
                    echo "Redis is ready!"
                    echo "All external services are ready."
          
          # Bootstrap script for database migration
          bootstrapScript: |
            #!/bin/bash
            set -e
            echo "Starting Superset bootstrap..."
            
            # Database migration
            echo "Running database upgrade..."
            superset db upgrade
            
            # Initialize roles and permissions
            echo "Initializing Superset..."
            superset init
            
            # Create default admin if doesn't exist
            if [ -n "${ADMIN_USERNAME}" ] && [ -n "${ADMIN_PASSWORD}" ]; then
              echo "Creating/updating admin user..."
              superset fab create-admin \
                --username "${ADMIN_USERNAME}" \
                --firstname "${ADMIN_FIRSTNAME}" \
                --lastname "${ADMIN_LASTNAME}" \
                --email "${ADMIN_EMAIL}" \
                --password "${ADMIN_PASSWORD}" || true
            fi
            
            echo "Bootstrap completed successfully"
          
          # Disable embedded PostgreSQL and Redis (using external instances)
          postgresql:
            enabled: false

          redis:
            enabled: false

          # Use chart's built-in extraEnvRaw to reference external secrets directly
          # This eliminates the need for PreSync hooks and intermediate secrets
          extraEnvRaw:
            # Database credentials from superset-secrets
            - name: DB_PASS
              valueFrom:
                secretKeyRef:
                  name: superset-secrets
                  key: POSTGRES_PASSWORD
            - name: SUPERSET_SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: superset-secrets
                  key: SECRET_KEY
            # Redis password (optional, can be empty for internal Redis)
            - name: REDIS_PASSWORD
              value: ""

          # External database configuration (non-sensitive values can be in values.yaml)
          extraEnv:
            DB_HOST: "postgresql.infra.svc.cluster.local"
            DB_PORT: "5432"
            DB_USER: "superset_user"
            DB_NAME: "superset"
            REDIS_HOST: "redis-master.infra.svc.cluster.local"
            REDIS_PORT: "6379"
            REDIS_PROTO: "redis"
            REDIS_DB: "1"
            REDIS_CELERY_DB: "0"
          
          # Superset configuration overrides
          configOverrides:
            secret_config: |
              import os
              SECRET_KEY = os.environ.get('SUPERSET_SECRET_KEY') or os.environ.get('SECRET_KEY')

            enable_oauth: |
              from flask_appbuilder.security.manager import AUTH_DB
              AUTH_TYPE = AUTH_DB

            custom_config: |
              # HTTPS/Proxy Configuration (essential for proper HTTPS handling behind ingress)
              ENABLE_PROXY_FIX = True
              PREFERRED_URL_SCHEME = 'https'
              SESSION_COOKIE_SECURE = True
              SESSION_COOKIE_HTTPONLY = True
              SESSION_COOKIE_SAMESITE = 'Lax'

              # Feature flags
              FEATURE_FLAGS = {
                  'ENABLE_TEMPLATE_PROCESSING': True,
                  'DASHBOARD_NATIVE_FILTERS': True,
                  'DASHBOARD_CROSS_FILTERS': True,
                  'DASHBOARD_RBAC': True,
                  'EMBEDDED_SUPERSET': True,
              }

              # Query settings
              SQL_MAX_ROW = 100000
              SQLLAB_ASYNC_TIME_LIMIT_SEC = 300
              SQLLAB_TIMEOUT = 300
              SUPERSET_WEBSERVER_TIMEOUT = 300

              # Security
              WTF_CSRF_ENABLED = True
              WTF_CSRF_TIME_LIMIT = None
              TALISMAN_ENABLED = True

              # Row level security
              ROW_LEVEL_SECURITY_ENABLED = True
          
          # Celery workers for async query execution - optimized
          supersetWorker:
            enabled: true
            replicaCount: 1
            resources:
              requests:
                cpu: 100m
                memory: 256Mi
              limits:
                cpu: 500m
                memory: 1Gi
            livenessProbe:
              exec:
                command:
                  - sh
                  - -c
                  - celery -A superset.tasks.celery_app:app inspect ping -d celery@$HOSTNAME
              initialDelaySeconds: 120
              periodSeconds: 60
              timeoutSeconds: 60
              failureThreshold: 3
            autoscaling:
              enabled: true
              minReplicas: 1
              maxReplicas: 4
              targetCPUUtilizationPercentage: 70
          
          # Celery beat for scheduled tasks - optimized
          supersetCeleryBeat:
            enabled: true
            resources:
              requests:
                cpu: 50m
                memory: 128Mi
              limits:
                cpu: 200m
                memory: 256Mi
          
          # Pod Disruption Budget for HA
          podDisruptionBudget:
            enabled: true
            minAvailable: 1
          
          # Security context
          securityContext:
            runAsUser: 1000
            runAsGroup: 1000
            fsGroup: 1000
            runAsNonRoot: true
          
          # Node affinity and tolerations (optional)
          affinity:
            podAntiAffinity:
              preferredDuringSchedulingIgnoredDuringExecution:
                - weight: 100
                  podAffinityTerm:
                    labelSelector:
                      matchExpressions:
                        - key: app
                          operator: In
                          values:
                            - superset
                    topologyKey: kubernetes.io/hostname

  destination:
    server: https://kubernetes.default.svc
    namespace: infra  # Deploy alongside storage services (PostgreSQL, Redis)
  
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
    retry:
      limit: 5
      backoff:
        duration: 5s
        factor: 2
        maxDuration: 3m

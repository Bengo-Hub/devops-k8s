name: Provision Cluster Services (Complete Setup)

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      setup_cluster:
        description: 'Set up Kubernetes cluster from scratch (requires VPS access). Set to false to skip.'
        required: false
        default: false
        type: boolean
      enable_cleanup:
        description: 'Enable cluster cleanup (DANGEROUS - deletes all data). Set to false to disable.'
        required: false
        default: true
        type: boolean

jobs:
  provision:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    env:
      skip_provision: 'false'
      # Configurable domains and IPs via GitHub secrets (with defaults)
      VPS_IP: ${{ secrets.VPS_IP || 'YOUR_VPS_IP' }}
      VPS_USER: ${{ secrets.VPS_USER || 'root' }}
      ARGOCD_DOMAIN: ${{ secrets.ARGOCD_DOMAIN || 'argocd.masterspace.co.ke' }}
      GRAFANA_DOMAIN: ${{ secrets.GRAFANA_DOMAIN || 'grafana.masterspace.co.ke' }}
      DB_NAMESPACE: ${{ secrets.DB_NAMESPACE || 'infra' }}
      MONITORING_NAMESPACE: ${{ secrets.MONITORING_NAMESPACE || 'infra' }}
      CLUSTER_NAME: ${{ secrets.CLUSTER_NAME || 'mss-prod' }}
      # Cleanup ENABLED by default (can be disabled via workflow input)
      ENABLE_CLEANUP: ${{ github.event_name == 'workflow_dispatch'
        && (github.event.inputs.enable_cleanup == 'false' && 'false' || 'true')
        || 'true' }}
      SETUP_CLUSTER: ${{ github.event_name == 'workflow_dispatch'
        && (github.event.inputs.setup_cluster == 'true' && 'true' || 'false')
        || 'false' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install DevOps tools (kubectl, helm, yq, argocd)
        uses: ./.github/actions/install-devops-tools
        with:
          install_trivy: 'false'

      - name: Install PostgreSQL client (psql)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client postgresql-client-common

      - name: Setup SSH for VPS access
        if: env.SETUP_CLUSTER == 'true'
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          echo "::group::Setting up SSH for VPS access"
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "âš ï¸  SSH_PRIVATE_KEY not provided. Skipping cluster setup."
            echo "SETUP_CLUSTER=false" >> $GITHUB_ENV
            echo "::endgroup::"
            exit 0
          fi
          
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/vps_key
          chmod 600 ~/.ssh/vps_key
          
          # Add VPS to known hosts
          ssh-keyscan -H ${VPS_IP} >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Test SSH connection
          ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_IP} "echo 'SSH connection successful'" || {
            echo "âŒ Failed to connect to VPS. Check SSH_PRIVATE_KEY and VPS_IP."
            echo "SETUP_CLUSTER=false" >> $GITHUB_ENV
            exit 0
          }
          
          echo "âœ… SSH connection established"
          echo "SETUP_CLUSTER=true" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: Setup VPS (Initial Server Configuration)
        if: env.SETUP_CLUSTER == 'true'
        run: |
          echo "::group::VPS Initial Setup"
          echo "Setting up VPS: ${VPS_IP}"
          
          # Copy scripts to VPS
          scp -i ~/.ssh/vps_key -o StrictHostKeyChecking=no \
            -r scripts/cluster/* ${VPS_USER}@${VPS_IP}:/tmp/k8s-setup/ || true
          
          # Run VPS setup
          ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_IP} << 'EOF'
            set -e
            mkdir -p /tmp/k8s-setup
            cd /tmp/k8s-setup
            
            # Make scripts executable
            chmod +x *.sh || true
            
            # Run VPS setup
            if [ -f setup-vps.sh ]; then
              CLUSTER_NAME=${CLUSTER_NAME:-mss-prod} bash setup-vps.sh
            else
              echo "âš ï¸  setup-vps.sh not found, skipping VPS setup"
            fi
          EOF
          
          echo "âœ… VPS setup complete"
          echo "::endgroup::"

      - name: Setup Container Runtime (containerd)
        if: env.SETUP_CLUSTER == 'true'
        run: |
          echo "::group::Container Runtime Setup"
          ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_IP} << 'EOF'
            set -e
            cd /tmp/k8s-setup
            
            if [ -f setup-containerd.sh ]; then
              bash setup-containerd.sh
            else
              echo "âš ï¸  setup-containerd.sh not found"
            fi
          EOF
          echo "âœ… Container runtime setup complete"
          echo "::endgroup::"

      - name: Setup Kubernetes Cluster
        if: env.SETUP_CLUSTER == 'true'
        env:
          CLUSTER_NAME: ${{ env.CLUSTER_NAME }}
          VPS_IP: ${{ env.VPS_IP }}
        run: |
          echo "::group::Kubernetes Cluster Setup"
          ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_IP} << EOF
            set -e
            cd /tmp/k8s-setup
            
            if [ -f setup-kubernetes.sh ]; then
              CLUSTER_NAME=${CLUSTER_NAME} VPS_IP=${VPS_IP} bash setup-kubernetes.sh
            else
              echo "âš ï¸  setup-kubernetes.sh not found"
            fi
          EOF
          
          # Retrieve kubeconfig
          echo "::group::Retrieving kubeconfig"
          ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_IP} \
            "cat /root/.kube/config" > /tmp/kubeconfig || \
            ssh -i ~/.ssh/vps_key -o StrictHostKeyChecking=no ${VPS_USER}@${VPS_IP} \
            "cat /home/ubuntu/.kube/config" > /tmp/kubeconfig || true
          
          if [ -f /tmp/kubeconfig ]; then
            # Update server address if needed
            sed -i "s|server: https://.*:6443|server: https://${VPS_IP}:6443|" /tmp/kubeconfig
            
            # Display base64 kubeconfig
            echo ""
            echo "ðŸ”‘ BASE64-ENCODED KUBECONFIG (Copy this to GitHub secret KUBE_CONFIG):"
            echo "=========================================="
            cat /tmp/kubeconfig | base64 -w 0
            echo ""
            echo "=========================================="
            echo ""
            echo "ðŸ“‹ NEXT STEPS:"
            echo "1. Copy the base64 kubeconfig above"
            echo "2. Go to: https://github.com/Bengo-Hub/devops-k8s/settings/secrets/actions"
            echo "3. Add secret: KUBE_CONFIG (paste the base64 value)"
            echo "4. Re-run this workflow to continue with infrastructure provisioning"
            echo ""
          fi
          echo "::endgroup::"
          echo "::endgroup::"

      - name: Configure kubeconfig
        env:
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          echo "::group::Checking KUBE_CONFIG"
          if [ -z "$KUBE_CONFIG_B64" ]; then
            echo "âŒ KUBE_CONFIG secret not provided."
            if [ "$SETUP_CLUSTER" = "true" ]; then
              echo "âš ï¸  Cluster was just set up. Please copy the kubeconfig from above and add it as KUBE_CONFIG secret."
            else
              echo "Please set KUBE_CONFIG at org/repo level with base64-encoded kubeconfig."
            fi
            echo "skip_provision=true" >> $GITHUB_ENV
            echo "::endgroup::"
            exit 0
          fi
          echo "âœ… KUBE_CONFIG secret found"
          echo "::endgroup::"
          
          echo "::group::Decoding and configuring kubeconfig"
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          echo "âœ… Kubeconfig written to ~/.kube/config"
          echo "::endgroup::"
          
          echo "::group::Testing cluster connectivity"
          if kubectl cluster-info; then
            echo "âœ… Successfully connected to Kubernetes cluster"
            kubectl get nodes || true
            echo "skip_provision=false" >> $GITHUB_ENV
          else
            echo "âŒ Failed to connect to cluster. Check your KUBE_CONFIG."
            echo "skip_provision=true" >> $GITHUB_ENV
            exit 1
          fi
          echo "::endgroup::"

      - name: Ensure scripts executable
        if: env.skip_provision != 'true'
        run: |
          chmod +x scripts/**/*.sh || true
          chmod +x scripts/*/*.sh || true

      - name: Check cluster health
        if: env.skip_provision != 'true'
        run: |
          echo "::group::Cluster Health Check"
          echo "Checking cluster status..."
          kubectl get nodes || true
          
          # Check for Pending pods
          PENDING_COUNT=$(kubectl get pods -A --field-selector=status.phase=Pending --no-headers 2>/dev/null | wc -l || echo "0")
          if [ "$PENDING_COUNT" -gt 0 ]; then
            echo "âš ï¸  Warning: Found $PENDING_COUNT Pending pods"
            echo "Running diagnostics..."
            ./scripts/diagnostics/diagnose-pending-pods.sh || true
          else
            echo "âœ… No Pending pods found"
          fi
          echo "::endgroup::"

      - name: Cleanup cluster (ENABLED by default)
        if: env.skip_provision != 'true'
        env:
          ENABLE_CLEANUP: ${{ env.ENABLE_CLEANUP }}
        run: |
          echo "::group::Cluster Cleanup"
          echo "ENABLE_CLEANUP=${ENABLE_CLEANUP}"
          if [ "$ENABLE_CLEANUP" = "true" ]; then
            echo "ðŸ§¹ Cleanup is ENABLED - This will delete ALL applications and data!"
            echo "âš ï¸  Deleting namespaces: erp, truload, infra, argocd, monitoring, cafe, treasury, notifications, auth-service"
            echo "âš ï¸  System namespaces preserved: kube-system, calico-system, cert-manager, ingress-nginx"
            export ENABLE_CLEANUP=true
            export FORCE_CLEANUP=true
            ./scripts/cluster/cleanup-cluster.sh
          else
            echo "âœ… Cleanup DISABLED - Skipping cluster cleanup"
            echo "â„¹ï¸  Existing infrastructure will be preserved"
            echo "â„¹ï¸  To disable cleanup, set enable_cleanup=false when running workflow manually"
          fi
          echo "::endgroup::"

      - name: Install storage provisioner (idempotent)
        if: env.skip_provision != 'true'
        run: |
          echo "::group::Installing Storage Provisioner"
          ./scripts/infrastructure/install-storage-provisioner.sh
          echo "::endgroup::"

      - name: Install databases (PostgreSQL & Redis - Shared Infrastructure)
        if: env.skip_provision != 'true'
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_ADMIN_PASSWORD: ${{ secrets.POSTGRES_ADMIN_PASSWORD || secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
          ENABLE_CLEANUP: ${{ env.ENABLE_CLEANUP }}
        run: |
          echo "::group::Installing Shared Databases (PostgreSQL & Redis in ${DB_NAMESPACE} namespace)"
          echo "Installing shared infrastructure databases..."
          echo "Namespace: ${DB_NAMESPACE}"
          echo "PostgreSQL will create admin_user for managing per-service databases"
          export NAMESPACE=${DB_NAMESPACE}
          export PG_DATABASE=postgres
          ./scripts/infrastructure/install-databases.sh
          echo "âœ… Shared databases installed in ${DB_NAMESPACE} namespace"
          echo "âœ… PostgreSQL admin_user created (can create per-service databases)"
          echo "âœ… Each service will create its own database during deployment"
          echo "::endgroup::"
      
      - name: Install RabbitMQ (Shared Infrastructure)
        if: env.skip_provision != 'true'
        env:
          RABBITMQ_PASSWORD: ${{ secrets.RABBITMQ_PASSWORD || 'rabbitmq' }}
          RABBITMQ_NAMESPACE: ${{ env.DB_NAMESPACE }}
          ENABLE_CLEANUP: ${{ env.ENABLE_CLEANUP }}
        run: |
          echo "::group::Installing RabbitMQ (Shared Infrastructure in ${RABBITMQ_NAMESPACE} namespace)"
          echo "Installing RabbitMQ as shared infrastructure..."
          echo "Namespace: ${RABBITMQ_NAMESPACE}"
          ./scripts/infrastructure/install-rabbitmq.sh
          echo "âœ… RabbitMQ installed in ${RABBITMQ_NAMESPACE} namespace"
          echo "âœ… All services can use shared RabbitMQ instance"
          echo "::endgroup::"

      - name: Configure ingress controller (idempotent)
        if: env.skip_provision != 'true'
        run: |
          echo "::group::Configuring NGINX Ingress Controller"
          ./scripts/infrastructure/configure-ingress-controller.sh
          echo "::endgroup::"

      - name: Install cert-manager (idempotent)
        if: env.skip_provision != 'true'
        run: |
          echo "::group::Installing cert-manager"
          ./scripts/infrastructure/install-cert-manager.sh
          echo "::endgroup::"

      - name: Install Argo CD (idempotent)
        if: env.skip_provision != 'true'
        env:
          ARGOCD_DOMAIN: ${{ env.ARGOCD_DOMAIN }}
        run: |
          echo "::group::Installing Argo CD"
          ./scripts/infrastructure/install-argocd.sh
          echo "::endgroup::"

      - name: Bootstrap Argo CD applications (app-of-apps)
        if: env.skip_provision != 'true'
        run: |
          echo "::group::Bootstrapping Argo CD applications"
          # Apply the root Application that manages apps under apps/
          if [ -f apps/root-app.yaml ]; then
            kubectl apply -f apps/root-app.yaml
            echo "âœ… root Application applied"
          else
            echo "âš ï¸ apps/root-app.yaml not found; skipping"
          fi
          
          # Also apply individual applications directly to ensure they're created
          echo "Applying individual ArgoCD Applications..."
          for app_file in apps/*/app.yaml; do
            if [ -f "$app_file" ]; then
              kubectl apply -f "$app_file" || echo "âš ï¸ Failed to apply $app_file"
              echo "âœ“ Applied: $app_file"
            fi
          done
          
          echo "Current ArgoCD Applications:"
          kubectl get applications -n argocd || true
          echo "::endgroup::"

      - name: Install Monitoring (idempotent)
        if: env.skip_provision != 'true'
        env:
          GRAFANA_DOMAIN: ${{ env.GRAFANA_DOMAIN }}
          MONITORING_NAMESPACE: ${{ env.MONITORING_NAMESPACE }}
          ENABLE_CLEANUP: ${{ env.ENABLE_CLEANUP }}
        run: |
          echo "::group::Installing Monitoring Stack"
          ./scripts/monitoring/install-monitoring.sh
          echo "::endgroup::"

      - name: Install Vertical Pod Autoscaler (VPA)
        if: env.skip_provision != 'true'
        run: |
          echo "::group::Installing Vertical Pod Autoscaler"
          ./scripts/infrastructure/install-vpa.sh
          echo "::endgroup::"

      - name: Setup Git Access (SSH Keys & Configuration)
        if: env.skip_provision != 'true'
        env:
          VPS_IP: ${{ env.VPS_IP }}
        run: |
          echo "::group::Setting up Git SSH Access"
          
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Generate SSH key pair for git operations (if not exists)
          if [ ! -f ~/.ssh/git_deploy_key ]; then
            echo "ðŸ”‘ Generating SSH key pair for git operations..."
            ssh-keygen -t ed25519 -C "vps-git-access@bengoerp" -f ~/.ssh/git_deploy_key -N ""
            chmod 600 ~/.ssh/git_deploy_key
            chmod 644 ~/.ssh/git_deploy_key.pub
          else
            echo "âœ… SSH key pair already exists"
          fi
          
          # Add GitHub to known hosts
          ssh-keyscan github.com >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Create SSH config for reliable git operations
          cat > ~/.ssh/config << 'EOF'
          Host github.com
              HostName github.com
              User git
              IdentityFile ~/.ssh/git_deploy_key
              IdentitiesOnly yes
              StrictHostKeyChecking no
          EOF
          chmod 600 ~/.ssh/config
          
          # Display public key for deploy key setup
          echo ""
          echo "ðŸ”‘ PUBLIC KEY FOR GITHUB DEPLOY KEY:"
          echo "====================================="
          cat ~/.ssh/git_deploy_key.pub
          echo "====================================="
          echo ""
          echo "ðŸ“‹ NEXT STEPS:"
          echo "1. Copy the public key above"
          echo "2. Go to: https://github.com/Bengo-Hub/devops-k8s/settings/keys"
          echo "3. Add deploy key with 'Allow write access' enabled"
          echo "4. Test: git clone git@github.com:Bengo-Hub/devops-k8s.git"
          echo ""
          
          echo "::endgroup::"
      
      - name: Summary
        if: ${{ env.skip_provision != 'true' }}
        env:
          VPS_IP: ${{ env.VPS_IP }}
          ARGOCD_DOMAIN: ${{ env.ARGOCD_DOMAIN }}
          GRAFANA_DOMAIN: ${{ env.GRAFANA_DOMAIN }}
          DB_NAMESPACE: ${{ env.DB_NAMESPACE }}
        run: |
          echo "::group::Cluster Provisioning Complete"
          echo "âœ… Storage provisioner installed"
          echo "âœ… Shared Databases installed (PostgreSQL & Redis in ${DB_NAMESPACE} namespace)"
          echo "  - PostgreSQL admin_user created for managing per-service databases"
          echo "  - Each service creates its own database during deployment"
          echo "âœ… RabbitMQ installed (shared infrastructure in ${DB_NAMESPACE} namespace)"
          echo "âœ… NGINX Ingress Controller configured"
          echo "âœ… cert-manager installed"
          echo "âœ… Argo CD installed (https://${ARGOCD_DOMAIN})"
          echo "âœ… Monitoring Stack installed (https://${GRAFANA_DOMAIN}) in ${DB_NAMESPACE} namespace"
          echo "âœ… Vertical Pod Autoscaler (VPA) installed"
          echo "âœ… Git SSH access configured"
          echo ""
          echo "Shared Infrastructure Credentials (${DB_NAMESPACE} namespace):"
          echo "- PostgreSQL admin_user: kubectl get secret postgresql -n ${DB_NAMESPACE} -o jsonpath='{.data.admin-user-password}' | base64 -d"
          echo "- PostgreSQL postgres user: kubectl get secret postgresql -n ${DB_NAMESPACE} -o jsonpath='{.data.postgres-password}' | base64 -d"
          echo "- Redis: kubectl get secret redis -n ${DB_NAMESPACE} -o jsonpath='{.data.redis-password}' | base64 -d"
          echo "- RabbitMQ: kubectl get secret rabbitmq -n ${DB_NAMESPACE} -o jsonpath='{.data.rabbitmq-password}' | base64 -d"
          echo ""
          echo "Per-Service Databases:"
          echo "- Each service (cafe-backend, erp-api, treasury-app, notifications-app) creates its own database"
          echo "- Database names: cafe, bengo_erp, treasury, notifications"
          echo "- Databases are created automatically during service deployment"
          echo ""
          echo "Configuration (via GitHub Secrets):"
          echo "- VPS_IP: ${VPS_IP}"
          echo "- ARGOCD_DOMAIN: ${ARGOCD_DOMAIN}"
          echo "- GRAFANA_DOMAIN: ${GRAFANA_DOMAIN}"
          echo "- DB_NAMESPACE: ${DB_NAMESPACE}"
          echo ""
          echo "Next steps:"
          echo "1. Set up GitHub deploy key (see workflow output above)"
          echo "2. Point DNS to your VPS IP (${VPS_IP})"
          echo "3. Configure Argo CD repository access"
          echo "4. Deploy applications via Argo CD (they will auto-create databases)"
          echo "5. Verify databases: kubectl -n ${DB_NAMESPACE} exec -it postgresql-0 -- psql -U admin_user -d postgres -c '\l'"
          echo "6. Verify VPA: kubectl get vpa --all-namespaces"
          echo "::endgroup::"

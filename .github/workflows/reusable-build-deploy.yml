name: Reusable Build and Deploy

on:
  workflow_call:
    inputs:
      # Generic branding and customization
      deployment_summary_title:
        required: false
        type: string
        default: "Deployment Summary"
        description: "Title for the deployment summary (e.g., 'MyApp Deployment Summary')"
      deployment_success_message:
        required: false
        type: string
        default: "Deployment completed! Application should be accessible via the URLs above."
        description: "Success message displayed in deployment summary"
      application_display_name:
        required: false
        type: string
        description: "Human-readable application name for display (defaults to app_name)"

      # Core deployment parameters
      app_name:
        required: true
        type: string
        description: "Application name (required, used for naming resources and ArgoCD applications)"
      registry_server:
        required: false
        type: string
        default: docker.io
        description: "Container registry server (e.g., docker.io, gcr.io, quay.io)"
      registry_namespace:
        required: false
        type: string
        default: codevertex
        description: "Registry namespace/organization (e.g., codevertex, myorg)"
      docker_context:
        required: false
        type: string
        default: .
        description: "Docker build context path (relative to repository root)"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
        description: "Path to Dockerfile (relative to docker_context)"
      image_repository:
        required: false
        type: string
        description: "Custom image repository (overrides registry_server/namespace/app_name)"
      deploy:
        required: false
        type: boolean
        default: false
        description: "Enable deployment phase (build, push, and deploy)"
      values_file_path:
        required: true
        type: string
        description: "Path to Helm values file in devops-k8s repository (e.g., apps/erp-api/values.yaml)"
      chart_repo_path:
        required: false
        type: string
        default: charts/app
        description: "Path to Helm chart in devops-k8s repository"
      namespace:
        required: false
        type: string
        default: default
        description: "Kubernetes namespace for deployment (must exist or be creatable)"
      # Git configuration for devops-k8s repo access
      git_user:
        required: false
        type: string
        default: "Titus Owuor"
        description: "Git commit author name for devops-k8s repository updates"
      git_email:
        required: false
        type: string
        default: "titusowuor30@gmail.com"
        description: "Git commit author email for devops-k8s repository updates"
      devops_repo:
        required: false
        type: string
        default: "Bengo-Hub/devops-k8s"
        description: "DevOps repository in format 'owner/repo' for Helm updates"
      # Database automation (optional)
      setup_databases:
        required: false
        type: boolean
        default: false
        description: "Enable automatic database setup (postgres, redis, mongo, mysql)"
      db_types:
        description: "Comma-separated list of databases to setup (postgres,redis,mongo,mysql)"
        required: false
        type: string
        default: "postgres,redis"
      env_secret_name:
        description: "Kubernetes Secret name to create/update with DB URLs"
        required: false
        type: string
        default: "app-env"
      provider:
        required: false
        type: string
        default: contabo
        description: "Cloud provider (contabo, aws, gcp, azure)"
      contabo_api:
        required: false
        type: boolean
        default: true
        description: "Enable Contabo API for instance management"
      contabo_instance_id:
        required: false
        type: string
        default: "202846760"
        description: "Contabo instance ID for API operations"
      contabo_ip:
        required: false
        type: string
        default: "77.237.232.66"
        description: "Contabo instance IP address"
      contabo_datacenter:
        required: false
        type: string
        default: "European Union 2"
        description: "Contabo datacenter location"
      contabo_region:
        required: false
        type: string
        default: "EU"
        description: "Contabo region (EU, US, etc.)"
      ssh_deploy:
        required: false
        type: boolean
        default: false
        description: "Enable SSH deployment to VPS"
      ssh_host:
        required: false
        type: string
        description: "SSH target host (IP or hostname)"
      ssh_user:
        required: false
        type: string
        description: "SSH username for deployment"
      ssh_port:
        required: false
        type: string
        default: "22"
        description: "SSH port (default: 22)"
      skip_files:
        required: false
        type: string
        description: "Comma-separated list of files to skip during Trivy filesystem scanning"
      run_migrations:
        required: false
        type: boolean
        default: false
        description: "Run database migrations after deployment (for Django apps)"
      migration_image_repo:
        required: false
        type: string
        description: "Image repository for migration jobs (defaults to registry_server/namespace/app_name)"
      migration_command:
        required: false
        type: string
        default: "python manage.py migrate"
        description: "Migration command to run"

  # Allow manual triggering for testing and direct execution
  workflow_dispatch:

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Normalize inputs for both workflow_call and workflow_dispatch
        id: inputs
        run: |
          # Handle both workflow_call and workflow_dispatch inputs
          APP_NAME="${APP_NAME}"
          REGISTRY_SERVER="${REGISTRY_SERVER:-docker.io}"
          REGISTRY_NAMESPACE="${REGISTRY_NAMESPACE:-codevertex}"
          DOCKER_CONTEXT="${DOCKER_CONTEXT:-.}"
          DOCKERFILE="${DOCKERFILE:-Dockerfile}"
          IMAGE_REPOSITORY="${IMAGE_REPOSITORY:-}"
          DEPLOY="${DEPLOY:-false}"
          VALUES_FILE_PATH="${VALUES_FILE_PATH}"
          CHART_REPO_PATH="${CHART_REPO_PATH:-charts/app}"
          NAMESPACE="${NAMESPACE:-default}"
          GIT_USER="${GIT_USER:-Titus Owuor}"
          GIT_EMAIL="${GIT_EMAIL:-titusowuor30@gmail.com}"
          DEVOPS_REPO="${DEVOPS_REPO:-Bengo-Hub/devops-k8s}"
          SETUP_DATABASES="${SETUP_DATABASES:-false}"
          DB_TYPES="${DB_TYPES:-postgres,redis}"
          ENV_SECRET_NAME="${ENV_SECRET_NAME:-app-env}"
          PROVIDER="${PROVIDER:-contabo}"
          CONTABO_API="${CONTABO_API:-true}"
          CONTABO_INSTANCE_ID="${CONTABO_INSTANCE_ID:-202846760}"
          CONTABO_IP="${CONTABO_IP:-77.237.232.66}"
          CONTABO_DATACENTER="${CONTABO_DATACENTER:-European Union 2}"
          CONTABO_REGION="${CONTABO_REGION:-EU}"
          SSH_DEPLOY="${SSH_DEPLOY:-false}"
          SSH_HOST="${SSH_HOST:-}"
          SSH_USER="${SSH_USER:-}"
          SSH_PORT="${SSH_PORT:-22}"
          SSH_DEPLOY_COMMAND="${SSH_DEPLOY_COMMAND:-}"
          SKIP_FILES="${SKIP_FILES:-}"
          SKIP_FS_SCAN="${SKIP_FS_SCAN:-false}"
          RUN_MIGRATIONS="${RUN_MIGRATIONS:-false}"
          MIGRATION_IMAGE_REPO="${MIGRATION_IMAGE_REPO:-}"
          MIGRATION_COMMAND="${MIGRATION_COMMAND:-python manage.py migrate}"

          # Generic branding inputs
          DEPLOYMENT_SUMMARY_TITLE="${DEPLOYMENT_SUMMARY_TITLE:-Deployment Summary}"
          DEPLOYMENT_SUCCESS_MESSAGE="${DEPLOYMENT_SUCCESS_MESSAGE:-Deployment completed! Application should be accessible via the URLs above.}"
          APPLICATION_DISPLAY_NAME="${APPLICATION_DISPLAY_NAME:-}"

          # Export all inputs for use in subsequent steps
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "registry_server=$REGISTRY_SERVER" >> $GITHUB_OUTPUT
          echo "registry_namespace=$REGISTRY_NAMESPACE" >> $GITHUB_OUTPUT
          echo "docker_context=$DOCKER_CONTEXT" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
          echo "image_repository=$IMAGE_REPOSITORY" >> $GITHUB_OUTPUT
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "values_file_path=$VALUES_FILE_PATH" >> $GITHUB_OUTPUT
          echo "chart_repo_path=$CHART_REPO_PATH" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "git_user=$GIT_USER" >> $GITHUB_OUTPUT
          echo "git_email=$GIT_EMAIL" >> $GITHUB_OUTPUT
          echo "devops_repo=$DEVOPS_REPO" >> $GITHUB_OUTPUT
          echo "setup_databases=$SETUP_DATABASES" >> $GITHUB_OUTPUT
          echo "db_types=$DB_TYPES" >> $GITHUB_OUTPUT
          echo "env_secret_name=$ENV_SECRET_NAME" >> $GITHUB_OUTPUT
          echo "provider=$PROVIDER" >> $GITHUB_OUTPUT
          echo "contabo_api=$CONTABO_API" >> $GITHUB_OUTPUT
          echo "contabo_instance_id=$CONTABO_INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "contabo_ip=$CONTABO_IP" >> $GITHUB_OUTPUT
          echo "contabo_datacenter=$CONTABO_DATACENTER" >> $GITHUB_OUTPUT
          echo "contabo_region=$CONTABO_REGION" >> $GITHUB_OUTPUT
          echo "ssh_deploy=$SSH_DEPLOY" >> $GITHUB_OUTPUT
          echo "ssh_host=$SSH_HOST" >> $GITHUB_OUTPUT
          echo "ssh_user=$SSH_USER" >> $GITHUB_OUTPUT
          echo "ssh_port=$SSH_PORT" >> $GITHUB_OUTPUT
          echo "skip_files=$SKIP_FILES" >> $GITHUB_OUTPUT
          echo "run_migrations=$RUN_MIGRATIONS" >> $GITHUB_OUTPUT
          echo "migration_image_repo=$MIGRATION_IMAGE_REPO" >> $GITHUB_OUTPUT
          echo "migration_command=$MIGRATION_COMMAND" >> $GITHUB_OUTPUT
          echo "deployment_summary_title=$DEPLOYMENT_SUMMARY_TITLE" >> $GITHUB_OUTPUT
          echo "deployment_success_message=$DEPLOYMENT_SUCCESS_MESSAGE" >> $GITHUB_OUTPUT
          echo "application_display_name=$APPLICATION_DISPLAY_NAME" >> $GITHUB_OUTPUT

          # Also set as environment variables for easier access
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "REGISTRY_SERVER=$REGISTRY_SERVER" >> $GITHUB_ENV
          echo "REGISTRY_NAMESPACE=$REGISTRY_NAMESPACE" >> $GITHUB_ENV
          echo "DOCKER_CONTEXT=$DOCKER_CONTEXT" >> $GITHUB_ENV
          echo "DOCKERFILE=$DOCKERFILE" >> $GITHUB_ENV
          echo "IMAGE_REPOSITORY=$IMAGE_REPOSITORY" >> $GITHUB_ENV
          echo "DEPLOY=$DEPLOY" >> $GITHUB_ENV
          echo "VALUES_FILE_PATH=$VALUES_FILE_PATH" >> $GITHUB_ENV
          echo "CHART_REPO_PATH=$CHART_REPO_PATH" >> $GITHUB_ENV
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
          echo "GIT_USER=$GIT_USER" >> $GITHUB_ENV
          echo "GIT_EMAIL=$GIT_EMAIL" >> $GITHUB_ENV
          echo "DEVOPS_REPO=$DEVOPS_REPO" >> $GITHUB_ENV
          echo "SETUP_DATABASES=$SETUP_DATABASES" >> $GITHUB_ENV
          echo "DB_TYPES=$DB_TYPES" >> $GITHUB_ENV
          echo "ENV_SECRET_NAME=$ENV_SECRET_NAME" >> $GITHUB_ENV
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "CONTABO_API=$CONTABO_API" >> $GITHUB_ENV
          echo "CONTABO_INSTANCE_ID=$CONTABO_INSTANCE_ID" >> $GITHUB_ENV
          echo "CONTABO_IP=$CONTABO_IP" >> $GITHUB_ENV
          echo "CONTABO_DATACENTER=$CONTABO_DATACENTER" >> $GITHUB_ENV
          echo "CONTABO_REGION=$CONTABO_REGION" >> $GITHUB_ENV
          echo "SSH_DEPLOY=$SSH_DEPLOY" >> $GITHUB_ENV
          echo "SSH_HOST=$SSH_HOST" >> $GITHUB_ENV
          echo "SSH_USER=$SSH_USER" >> $GITHUB_ENV
          echo "SSH_PORT=$SSH_PORT" >> $GITHUB_ENV
          echo "SSH_DEPLOY_COMMAND=$SSH_DEPLOY_COMMAND" >> $GITHUB_ENV
          echo "SKIP_FILES=$SKIP_FILES" >> $GITHUB_ENV
          echo "SKIP_FS_SCAN=$SKIP_FS_SCAN" >> $GITHUB_ENV
          echo "RUN_MIGRATIONS=$RUN_MIGRATIONS" >> $GITHUB_ENV
          echo "MIGRATION_IMAGE_REPO=$MIGRATION_IMAGE_REPO" >> $GITHUB_ENV
          echo "MIGRATION_COMMAND=$MIGRATION_COMMAND" >> $GITHUB_ENV
          echo "DEPLOYMENT_SUMMARY_TITLE=$DEPLOYMENT_SUMMARY_TITLE" >> $GITHUB_ENV
          echo "DEPLOYMENT_SUCCESS_MESSAGE=$DEPLOYMENT_SUCCESS_MESSAGE" >> $GITHUB_ENV
          echo "APPLICATION_DISPLAY_NAME=$APPLICATION_DISPLAY_NAME" >> $GITHUB_ENV

      - name: Configure SSH for build secrets (optional)
        env:
          SSH_PRIV: ${{ secrets.SSH_PRIVATE_KEY }}
          DOCKER_SSH_KEY_B64: ${{ secrets.DOCKER_SSH_KEY }}
        run: |
          mkdir -p -m 0700 $HOME/.ssh

          # Check if SSH keys are available
          USE_SSH=false
          if [ -n "${DOCKER_SSH_KEY_B64:-}" ] && [ "$DOCKER_SSH_KEY_B64" != "" ]; then
            echo "Found DOCKER_SSH_KEY, will use SSH for builds"
            USE_SSH=true
          elif [ -n "${SSH_PRIV:-}" ] && [ "$SSH_PRIV" != "" ]; then
            echo "Found SSH_PRIVATE_KEY, will use SSH for builds"
            USE_SSH=true
          fi

          if [ "$USE_SSH" = "true" ]; then
            if [ -n "${DOCKER_SSH_KEY_B64:-}" ] && [ "$DOCKER_SSH_KEY_B64" != "" ]; then
              echo "Loading DOCKER_SSH_KEY"
              echo "$DOCKER_SSH_KEY_B64" | base64 -d > $HOME/.ssh/id_rsa
            else
              echo "Loading SSH_PRIVATE_KEY as fallback"
              printf "%s" "$SSH_PRIV" > $HOME/.ssh/id_rsa
            fi
            chmod 0600 $HOME/.ssh/id_rsa
            ssh-keyscan github.com >> $HOME/.ssh/known_hosts 2>/dev/null || true
            eval "$(ssh-agent)"
            # Add SSH key with passphrase "codevertex" for automated deployments
            echo "codevertex" | SSH_ASKPASS=/bin/echo ssh-add $HOME/.ssh/id_rsa 2>/dev/null || {
              echo "‚ùå Failed to add SSH key to agent - passphrase may be incorrect"
              exit 1
            }
            echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
            echo "SSH configured successfully"
          else
            echo "No SSH keys found, will build without SSH"
            echo "SSH_AUTH_SOCK=" >> $GITHUB_ENV
          fi

      - name: Determine image repository
        id: img
        env:
          REG_SVR: ${{ steps.inputs.outputs.registry_server }}
          REG_NS: ${{ steps.inputs.outputs.registry_namespace }}
        run: |
          if [ -n "${IMAGE_REPOSITORY}" ]; then
            echo "repo=${IMAGE_REPOSITORY}" >> $GITHUB_OUTPUT
          else
            echo "repo=${REG_SVR}/${REG_NS}/${APP_NAME}" >> $GITHUB_OUTPUT
          fi

      - name: Log in to registry (optional)
        if: ${{ secrets.REGISTRY_USERNAME != '' && secrets.REGISTRY_PASSWORD != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.inputs.outputs.registry_server }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Derive short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Install DevOps Tools
        uses: ./.github/actions/install-devops-tools

      - name: Trivy FS scan
        if: ${{ steps.inputs.outputs.skip_fs_scan != 'true' }}
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          scan-ref: .
          exit-code: '0'
          skip-files: "${{ steps.inputs.outputs.skip_files }}"

      - name: Build image (with SSH)
        if: ${{ env.SSH_AUTH_SOCK != '' && env.SSH_AUTH_SOCK != null }}
        run: |
          echo "üîë Building with SSH support"
          echo "üì¶ Image: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          DOCKER_BUILDKIT=1 docker build "${DOCKER_CONTEXT}" \
            -f "${DOCKERFILE}" \
            -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}" \
            --ssh default="$SSH_AUTH_SOCK"

      - name: Build image (no SSH)
        if: ${{ env.SSH_AUTH_SOCK == '' || env.SSH_AUTH_SOCK == null }}
        run: |
          echo "üö´ Building without SSH (no keys configured)"
          echo "üì¶ Image: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          DOCKER_BUILDKIT=1 docker build "${DOCKER_CONTEXT}" \
            -f "${DOCKERFILE}" \
            -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Trivy Image scan
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}
          exit-code: '0'

      - name: Push image
        if: ${{ steps.inputs.outputs.deploy }}
        run: docker push "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Setup databases (optional)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ steps.inputs.outputs.setup_databases }}
        timeout-minutes: 10
        continue-on-error: true
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          DB_TYPES: ${{ steps.inputs.outputs.db_types }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          set -e
          echo "Setting up databases in namespace ${NS}: ${DB_TYPES}"
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"

          # Tools
          sudo apt-get update -y && sudo apt-get install -y jq curl

          # Generate passwords if not provided
          gen_pwd() { openssl rand -hex 16; }
          : "${POSTGRES_PASSWORD:=$(gen_pwd)}"; : "${REDIS_PASSWORD:=$(gen_pwd)}"; : "${MONGO_PASSWORD:=$(gen_pwd)}"; : "${MYSQL_PASSWORD:=$(gen_pwd)}"

          echo "::group::Install Helm repos"
          helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>&1 || true
          helm repo update >/dev/null 2>&1 || true
          echo "::endgroup::"

          # Parse db types
          SAVEIFS=$IFS; IFS=','; set -f; types=($DB_TYPES); IFS=$SAVEIFS; set +f

          DB_SETUP_SUCCESS=0
          DB_SETUP_TOTAL=${#types[@]}

          for db in "${types[@]}"; do
            db=$(echo "$db" | xargs)
            echo "::group::Installing $db"

            case "$db" in
              postgres)
                echo "Installing PostgreSQL..."
                if helm upgrade --install postgresql bitnami/postgresql -n "$NS" \
                  --set global.postgresql.auth.postgresPassword="$POSTGRES_PASSWORD" \
                  --set global.postgresql.auth.database="appdb" \
                  --wait --timeout=300s; then
                  echo "‚úÖ PostgreSQL installed successfully"
                  export POSTGRES_URL="postgresql://postgres:${POSTGRES_PASSWORD}@postgresql.${NS}.svc.cluster.local:5432/appdb"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install PostgreSQL"
                fi
                ;;
              redis)
                echo "Installing Redis..."
                if helm upgrade --install redis bitnami/redis -n "$NS" \
                  --set global.redis.password="$REDIS_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "‚úÖ Redis installed successfully"
                  export REDIS_URL="redis://:${REDIS_PASSWORD}@redis-master.${NS}.svc.cluster.local:6379/0"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install Redis"
                fi
                ;;
              mongo|mongodb)
                echo "Installing MongoDB..."
                if helm upgrade --install mongodb bitnami/mongodb -n "$NS" \
                  --set auth.rootPassword="$MONGO_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "‚úÖ MongoDB installed successfully"
                  export MONGO_URL="mongodb://root:${MONGO_PASSWORD}@mongodb.${NS}.svc.cluster.local:27017/?authSource=admin"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install MongoDB"
                fi
                ;;
              mysql)
                echo "Installing MySQL..."
                if helm upgrade --install mysql bitnami/mysql -n "$NS" \
                  --set auth.rootPassword="$MYSQL_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "‚úÖ MySQL installed successfully"
                  export MYSQL_URL="mysql://root:${MYSQL_PASSWORD}@mysql.${NS}.svc.cluster.local:3306/appdb"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install MySQL"
                fi
                ;;
              *)
                echo "‚ö†Ô∏è Unknown database type: $db"
                ;;
            esac
            echo "::endgroup::"
          done

          echo "üìä Database setup summary: $DB_SETUP_SUCCESS/$DB_SETUP_TOTAL successful"

          # Create/update environment secret with database URLs
          echo "::group::Creating environment secret"
          LITS=""
          [ -n "$POSTGRES_URL" ] && LITS="$LITS --from-literal=DATABASE_URL=$POSTGRES_URL"
          [ -n "$REDIS_URL" ] && LITS="$LITS --from-literal=REDIS_URL=$REDIS_URL --from-literal=CELERY_BROKER_URL=$REDIS_URL --from-literal=CELERY_RESULT_BACKEND=$REDIS_URL"
          [ -n "$MONGO_URL" ] && LITS="$LITS --from-literal=MONGO_URL=$MONGO_URL"
          [ -n "$MYSQL_URL" ] && LITS="$LITS --from-literal=MYSQL_URL=$MYSQL_URL"

          if [ -n "$LITS" ]; then
            if kubectl -n "$NS" create secret generic "${ENV_SECRET_NAME}" $LITS --dry-run=client -o yaml | kubectl apply -f -; then
              echo "‚úÖ Environment secret created/updated successfully"
            else
              echo "‚ùå Failed to create/update environment secret"
            fi
          else
            echo "‚ÑπÔ∏è No database URLs were generated; skipping secret creation"
          fi
          echo "::endgroup::"

      - name: Contabo API bootstrap (ensure instance ready)
        id: contabo_bootstrap
        if: ${{ steps.inputs.outputs.deploy }} && ${{ steps.inputs.outputs.provider }} == 'contabo' && ${{ steps.inputs.outputs.contabo_api }}
        env:
          CLIENT_ID: ${{ secrets.CONTABO_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CONTABO_CLIENT_SECRET }}
          API_USER: ${{ secrets.CONTABO_API_USERNAME }}
          API_PASS: ${{ secrets.CONTABO_API_PASSWORD }}
          INSTANCE_ID: ${{ steps.inputs.outputs.contabo_instance_id }}
        run: |
          if [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ] || [ -z "$API_USER" ] || [ -z "$API_PASS" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Missing Contabo API credentials or instance id, will rely on SSH fallback if enabled"; exit 0; fi
          sudo apt-get update -y && sudo apt-get install -y jq curl
          TOKEN=$(curl -s -X POST https://auth.contabo.com/oauth2/token \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            -d "grant_type=password&username=${API_USER}&password=${API_PASS}&client_id=${CLIENT_ID}&client_secret=${CLIENT_SECRET}&scope=openid")
          ACCESS_TOKEN=$(echo "$TOKEN" | jq -r '.access_token')
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then echo "Failed to acquire Contabo token"; exit 0; fi
          INFO=$(curl -s -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID)
          STATUS=$(echo "$INFO" | jq -r '.status // .data[0].status')
          IP=$(echo "$INFO" | jq -r '.publicIpConfig.ip || .data[0].publicIpConfig.ip')
          echo "Contabo instance status: $STATUS, ip: $IP"
          echo "contabo_ip=$IP" >> $GITHUB_OUTPUT
          # Optionally ensure instance is powered on
          if [ "$STATUS" != "running" ] && [ "$STATUS" != "ACTIVE" ]; then
            curl -s -X POST -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID/start || true
          fi

      - name: Update values in devops-k8s
        if: ${{ steps.inputs.outputs.deploy }}
        timeout-minutes: 5
        env:
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
          VALUES_PATH: ${{ steps.inputs.outputs.values_file_path }}
          IMAGE_REPO: ${{ steps.img.outputs.repo }}
          DEVOPS_REPO: ${{ steps.inputs.outputs.devops_repo }}
          GIT_USER: ${{ steps.inputs.outputs.git_user }}
          GIT_EMAIL: ${{ steps.inputs.outputs.git_email }}
        run: |
          # Ensure SSH is configured for git operations
          if [ -n "${SSH_AUTH_SOCK:-}" ] && [ "$SSH_AUTH_SOCK" != "" ]; then
            echo "üîë Using SSH for git operations"
            export SSH_AUTH_SOCK="$SSH_AUTH_SOCK"

            # Create SSH config file for reliable git operations
            mkdir -p ~/.ssh
            cat > ~/.ssh/config << 'EOF'
            Host github.com
                HostName github.com
                User git
                IdentitiesOnly yes
                StrictHostKeyChecking no
            EOF
            chmod 600 ~/.ssh/config

            # Set SSH key path for git operations
            if [ -n "${DOCKER_SSH_KEY_B64:-}" ]; then
              echo "Using DOCKER_SSH_KEY for git operations"
              echo "$DOCKER_SSH_KEY_B64" | base64 -d > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            elif [ -n "${SSH_PRIV:-}" ]; then
              echo "Using SSH_PRIVATE_KEY for git operations"
              printf "%s" "$SSH_PRIV" > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            fi

            echo "‚úÖ SSH configured for git operations"
          else
            echo "‚ö†Ô∏è SSH not configured, git operations may fail"
          fi

          git config user.name "$GIT_USER"
          git config user.email "$GIT_EMAIL"

          # Retry git operations with exponential backoff
          max_retries=3
          for ((i=1; i<=max_retries; i++)); do
            echo "üîÑ Git operation attempt $i/$max_retries"

            if git pull --rebase; then
              echo "‚úÖ Git pull successful"
              break
            else
              echo "‚ùå Git pull failed (attempt $i/$max_retries)"
              if [ $i -eq $max_retries ]; then
                echo "üí• All git pull attempts failed, continuing with local repo"
                break
              fi
              sleep $((2 ** (i-1)))  # Exponential backoff: 1s, 2s, 4s
            fi
          done

          # Update Helm values
          if [ -f "$VALUES_PATH" ]; then
            echo "üìù Updating Helm values: $VALUES_PATH"
            yq -yi ".image.repository = \"${IMAGE_REPO}\" | .image.tag = \"${SHORT_SHA}\"" "${VALUES_PATH}"

            if [ $? -eq 0 ]; then
              echo "‚úÖ Helm values updated successfully"

              # Check if there are changes to commit
              if git diff --quiet HEAD "${VALUES_PATH}"; then
                echo "‚ÑπÔ∏è No changes to commit"
              else
                echo "üíæ Committing changes"
                git add "${VALUES_PATH}"

                # Retry git commit
                if git commit -m "${APP_NAME}:${SHORT_SHA} released"; then
                  echo "‚úÖ Changes committed"

                  # Retry git push with exponential backoff
                  push_max_retries=3
                  for ((j=1; j<=push_max_retries; j++)); do
                    echo "üîÑ Git push attempt $j/$push_max_retries"
                    if git push; then
                      echo "‚úÖ Git push successful"
                      break
                    else
                      echo "‚ùå Git push failed (attempt $j/$push_max_retries)"
                      if [ $j -eq $push_max_retries ]; then
                        echo "üí• All git push attempts failed"
                        echo "‚ö†Ô∏è Deployment will continue despite git push failure"
                      fi
                      sleep $((2 ** (j-1)))
                    fi
                  done
                else
                  echo "‚ùå Git commit failed"
                fi
              fi
            else
              echo "‚ùå Failed to update Helm values"
            fi
          else
            echo "‚ö†Ô∏è Helm values file not found: $VALUES_PATH"
          fi

      - name: Apply kube secrets (optional)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ secrets.KUBE_CONFIG }} != ''
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"
          if [ -f kubeSecrets/devENV.yaml ]; then
            kubectl apply -f kubeSecrets/devENV.yaml || true
          fi

      - name: Ensure default JWT secret (when KUBE_CONFIG provided)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ secrets.KUBE_CONFIG }} != ''
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          SECRET_NAME: ${{ steps.inputs.outputs.env_secret_name }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -e
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"
          JWT=$(openssl rand -hex 32)
          if kubectl -n "$NS" get secret "$SECRET_NAME" >/dev/null 2>&1; then
            # Patch only if key missing
            if ! kubectl -n "$NS" get secret "$SECRET_NAME" -o jsonpath='{.data.JWT_SECRET}' >/dev/null 2>&1; then
              kubectl -n "$NS" patch secret "$SECRET_NAME" -p "{\"stringData\":{\"JWT_SECRET\":\"$JWT\"}}"
            fi
          else
            kubectl -n "$NS" create secret generic "$SECRET_NAME" --from-literal=JWT_SECRET="$JWT"
          fi

      - name: SSH deploy to VPS (optional)
        if: ${{ steps.inputs.outputs.ssh_deploy }} || (${{ steps.inputs.outputs.provider }} == 'contabo' && ${{ steps.inputs.outputs.contabo_api }} && ${{ steps.vars.outputs.short_sha }} != '' )
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ steps.inputs.outputs.ssh_host || steps.inputs.outputs.contabo_ip || steps.contabo_bootstrap.outputs.contabo_ip }}
          username: ${{ steps.inputs.outputs.ssh_user }}
          port: ${{ steps.inputs.outputs.ssh_port }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            echo "Logging into registry"
            echo '${{ secrets.REGISTRY_PASSWORD }}' | docker login ${REGISTRY_SERVER} -u '${{ secrets.REGISTRY_USERNAME }}' --password-stdin || true
            echo "Pulling image"
            docker pull "${IMAGE_REPO}:${SHORT_SHA}"
            echo "Restarting container"
            docker rm -f ${APP_NAME} || true
            docker run -d --restart always --name ${APP_NAME} -p 0.0.0.0:80:80 "${IMAGE_REPO}:${SHORT_SHA}"

      - name: Run database migrations (Django apps)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ steps.inputs.outputs.run_migrations }} && ${{ secrets.KUBE_CONFIG }} != ''
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          IMAGE_REPO: ${{ steps.inputs.outputs.migration_image_repo != '' && steps.inputs.outputs.migration_image_repo || steps.img.outputs.repo }}
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
          ENV_SECRET_NAME: ${{ steps.inputs.outputs.env_secret_name }}
        run: |
          echo "üîÑ Running database migrations for ${APP_NAME}"
          
          # Only run migrations if KUBE_CONFIG is available
          if [ -z "$KUBE_CONFIG_B64" ]; then
            echo "‚è≠Ô∏è Skipping migrations - no KUBE_CONFIG available"
            exit 0
          fi

          echo "::group::Running database migrations"
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

          # Create migration job with improved error handling
          cat > /tmp/migrate-job.yaml <<EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: ${APP_NAME}-migrate-${SHORT_SHA}
            namespace: ${NS}
          spec:
            ttlSecondsAfterFinished: 600
            backoffLimit: 3
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: migrate
                  image: ${IMAGE_REPO}:${SHORT_SHA}
                  command: ["${MIGRATION_COMMAND}"]
                  envFrom:
                  - secretRef:
                      name: ${ENV_SECRET_NAME}
          EOF

          kubectl apply -f /tmp/migrate-job.yaml
          kubectl wait --for=condition=complete job/${APP_NAME}-migrate-${SHORT_SHA} -n ${NS} --timeout=300s || {
            echo "‚ùå Migration job failed or timed out"
            echo "Migration job logs:"
            kubectl logs job/${APP_NAME}-migrate-${SHORT_SHA} -n ${NS} --tail=50 || true
            kubectl describe job ${APP_NAME}-migrate-${SHORT_SHA} -n ${NS} || true
            exit 1
          }
          echo "‚úÖ Database migrations completed"
          echo "::endgroup::"


      # Add cleanup step to ensure no leftover processes or files
      - name: Cleanup temporary files
        if: always()
        run: |
          # Clean up any temporary files and stop background processes
          rm -rf $HOME/.ssh/id_rsa* 2>/dev/null || true
          rm -f /tmp/migrate-job.yaml 2>/dev/null || true
          # Kill any hanging kubectl processes
          pkill -f kubectl || true

          # Database information if setup was enabled
          if [[ "${SETUP_DATABASES}" == "true" ]]; then
            echo "### üóÑÔ∏è Database Setup" >> $GITHUB_STEP_SUMMARY
            echo "- **Databases:** ${DB_TYPES}" >> $GITHUB_STEP_SUMMARY
            echo "- **Secret:** ${ENV_SECRET_NAME}" >> $GITHUB_STEP_SUMMARY
            echo "- **Namespace:** ${NAMESPACE}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### üìã Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. **Verify ArgoCD Sync:** Check that ArgoCD has synced the new image tag" >> $GITHUB_STEP_SUMMARY
          echo "2. **Test Application:** Access the service URLs listed above" >> $GITHUB_STEP_SUMMARY
          echo "3. **Monitor Logs:** Check application and database logs for any issues" >> $GITHUB_STEP_SUMMARY
          echo "4. **SSL Certificate:** Configure ingress with SSL certificate for HTTPS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### üîß Useful Commands" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Check ArgoCD sync status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get applications -n argocd" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check application logs" >> $GITHUB_STEP_SUMMARY
          echo "kubectl logs -l app=${APP_NAME} -n ${NAMESPACE}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check service status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods,svc,ingress -l app=${APP_NAME} -n ${NAMESPACE}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "üéâ **${DEPLOYMENT_SUCCESS_MESSAGE}**" >> $GITHUB_STEP_SUMMARY

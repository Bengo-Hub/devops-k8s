name: Reusable Build and Deploy

on:
  workflow_call:
    inputs:
      # Generic branding and customization
      deployment_summary_title:
        required: false
        type: string
        default: "Deployment Summary"
        description: "Title for the deployment summary (e.g., 'MyApp Deployment Summary')"
      deployment_success_message:
        required: false
        type: string
        default: "Deployment completed! Application should be accessible via the URLs above."
        description: "Success message displayed in deployment summary"
      application_display_name:
        required: false
        type: string
        description: "Human-readable application name for display (defaults to app_name)"

      # Core deployment parameters
      app_name:
        required: true
        type: string
        description: "Application name (required, used for naming resources and ArgoCD applications)"
      registry_server:
        required: false
        type: string
        default: docker.io
        description: "Container registry server (e.g., docker.io, gcr.io, quay.io)"
      registry_namespace:
        required: false
        type: string
        default: codevertex
        description: "Registry namespace/organization (e.g., codevertex, myorg)"
      docker_context:
        required: false
        type: string
        default: .
        description: "Docker build context path (relative to repository root)"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
        description: "Path to Dockerfile (relative to docker_context)"
      image_repository:
        required: false
        type: string
        description: "Custom image repository (overrides registry_server/namespace/app_name)"
      deploy:
        required: false
        type: boolean
        default: false
        description: "Enable deployment phase (build, push, and deploy)"
      values_file_path:
        required: true
        type: string
        description: "Path to Helm values file in devops-k8s repository (e.g., apps/erp-api/values.yaml)"
      chart_repo_path:
        required: false
        type: string
        default: charts/app
        description: "Path to Helm chart in devops-k8s repository"
      namespace:
        required: false
        type: string
        default: default
        description: "Kubernetes namespace for deployment (must exist or be creatable)"
      # Git configuration for devops-k8s repo access
      git_user:
        required: false
        type: string
        default: "Titus Owuor"
        description: "Git commit author name for devops-k8s repository updates"
      git_email:
        required: false
        type: string
        default: "titusowuor30@gmail.com"
        description: "Git commit author email for devops-k8s repository updates"
      devops_repo:
        required: false
        type: string
        default: "Bengo-Hub/devops-k8s"
        description: "DevOps repository in format 'owner/repo' for Helm updates"
      # Database automation (optional)
      setup_databases:
        required: false
        type: boolean
        default: false
        description: "Enable automatic database setup (postgres, redis, mongo, mysql)"
      db_types:
        description: "Comma-separated list of databases to setup (postgres,redis,mongo,mysql)"
        required: false
        type: string
        default: "postgres,redis"
      env_secret_name:
        description: "Kubernetes Secret name to create/update with DB URLs"
        required: false
        type: string
        default: "app-env"
      provider:
        required: false
        type: string
        default: contabo
        description: "Cloud provider (contabo, aws, gcp, azure)"
      contabo_api:
        required: false
        type: boolean
        default: true
        description: "Enable Contabo API for instance management"
      contabo_instance_id:
        required: false
        type: string
        default: "202846760"
        description: "Contabo instance ID for API operations"
      contabo_ip:
        required: false
        type: string
        default: "77.237.232.66"
        description: "Contabo instance IP address"
      contabo_datacenter:
        required: false
        type: string
        default: "European Union 2"
        description: "Contabo datacenter location"
      contabo_region:
        required: false
        type: string
        default: "EU"
        description: "Contabo region (EU, US, etc.)"
      ssh_deploy:
        required: false
        type: boolean
        default: false
        description: "Enable SSH deployment to VPS"
      ssh_host:
        required: false
        type: string
        description: "SSH target host (IP or hostname)"
      ssh_user:
        required: false
        type: string
        description: "SSH username for deployment"
      ssh_port:
        required: false
        type: string
        default: "22"
        description: "SSH port (default: 22)"
      skip_files:
        required: false
        type: string
        description: "Comma-separated list of files to skip during Trivy filesystem scanning"
      skip_fs_scan:
        required: false
        type: boolean
        default: false
        description: "Skip filesystem scanning entirely"
    secrets:
      REGISTRY_USERNAME:
        required: false
      REGISTRY_PASSWORD:
        required: false
      KUBE_CONFIG:
        required: false
      SSH_PRIVATE_KEY:
        required: false
      DOCKER_SSH_KEY:
        required: false
      # Optional DB credentials (auto-generated if not provided)
      POSTGRES_PASSWORD:
        required: false
      REDIS_PASSWORD:
        required: false
      MONGO_PASSWORD:
        required: false
      MYSQL_PASSWORD:
        required: false
      CONTABO_CLIENT_ID:
        required: false
      CONTABO_CLIENT_SECRET:
        required: false
      CONTABO_API_USERNAME:
        required: false
      CONTABO_API_PASSWORD:
        required: false

  # Allow manual triggering for testing and direct execution
  workflow_dispatch:

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    secrets:
      REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
      KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
      DOCKER_SSH_KEY: ${{ secrets.DOCKER_SSH_KEY }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
      MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}
      MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
      CONTABO_CLIENT_ID: ${{ secrets.CONTABO_CLIENT_ID }}
      CONTABO_CLIENT_SECRET: ${{ secrets.CONTABO_CLIENT_SECRET }}
      CONTABO_API_USERNAME: ${{ secrets.CONTABO_API_USERNAME }}
      CONTABO_API_PASSWORD: ${{ secrets.CONTABO_API_PASSWORD }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Normalize inputs for both workflow_call and workflow_dispatch
        id: inputs
        run: |
          # Handle both workflow_call and workflow_dispatch inputs
          APP_NAME="${{ inputs.app_name || github.event.inputs.app_name }}"
          REGISTRY_SERVER="${{ inputs.registry_server || github.event.inputs.registry_server || 'docker.io' }}"
          REGISTRY_NAMESPACE="${{ inputs.registry_namespace || github.event.inputs.registry_namespace || 'codevertex' }}"
          DOCKER_CONTEXT="${{ inputs.docker_context || github.event.inputs.docker_context || '.' }}"
          DOCKERFILE="${{ inputs.dockerfile || github.event.inputs.dockerfile || 'Dockerfile' }}"
          IMAGE_REPOSITORY="${{ inputs.image_repository || github.event.inputs.image_repository || '' }}"
          DEPLOY="${{ inputs.deploy || github.event.inputs.deploy || false }}"
          VALUES_FILE_PATH="${{ inputs.values_file_path || github.event.inputs.values_file_path }}"
          CHART_REPO_PATH="${{ inputs.chart_repo_path || github.event.inputs.chart_repo_path || 'charts/app' }}"
          NAMESPACE="${{ inputs.namespace || github.event.inputs.namespace || 'default' }}"
          GIT_USER="${{ inputs.git_user || github.event.inputs.git_user || 'Titus Owuor' }}"
          GIT_EMAIL="${{ inputs.git_email || github.event.inputs.git_email || 'titusowuor30@gmail.com' }}"
          DEVOPS_REPO="${{ inputs.devops_repo || github.event.inputs.devops_repo || 'Bengo-Hub/devops-k8s' }}"
          SETUP_DATABASES="${{ inputs.setup_databases || github.event.inputs.setup_databases || false }}"
          DB_TYPES="${{ inputs.db_types || github.event.inputs.db_types || 'postgres,redis' }}"
          ENV_SECRET_NAME="${{ inputs.env_secret_name || github.event.inputs.env_secret_name || 'app-env' }}"
          PROVIDER="${{ inputs.provider || github.event.inputs.provider || 'contabo' }}"
          CONTABO_API="${{ inputs.contabo_api || github.event.inputs.contabo_api || true }}"
          CONTABO_INSTANCE_ID="${{ inputs.contabo_instance_id || github.event.inputs.contabo_instance_id || '202846760' }}"
          CONTABO_IP="${{ inputs.contabo_ip || github.event.inputs.contabo_ip || '77.237.232.66' }}"
          CONTABO_DATACENTER="${{ inputs.contabo_datacenter || github.event.inputs.contabo_datacenter || 'European Union 2' }}"
          CONTABO_REGION="${{ inputs.contabo_region || github.event.inputs.contabo_region || 'EU' }}"
          SSH_DEPLOY="${{ inputs.ssh_deploy || github.event.inputs.ssh_deploy || false }}"
          SSH_HOST="${{ inputs.ssh_host || github.event.inputs.ssh_host || '' }}"
          SSH_USER="${{ inputs.ssh_user || github.event.inputs.ssh_user || '' }}"
          SSH_PORT="${{ inputs.ssh_port || github.event.inputs.ssh_port || '22' }}"
          SSH_DEPLOY_COMMAND="${{ inputs.ssh_deploy_command || github.event.inputs.ssh_deploy_command || '' }}"
          SKIP_FILES="${{ inputs.skip_files || github.event.inputs.skip_files || '' }}"
          SKIP_FS_SCAN="${{ inputs.skip_fs_scan || github.event.inputs.skip_fs_scan || false }}"

          # Generic branding inputs
          DEPLOYMENT_SUMMARY_TITLE="${{ inputs.deployment_summary_title || github.event.inputs.deployment_summary_title || 'Deployment Summary' }}"
          DEPLOYMENT_SUCCESS_MESSAGE="${{ inputs.deployment_success_message || github.event.inputs.deployment_success_message || 'Deployment completed! Application should be accessible via the URLs above.' }}"
          APPLICATION_DISPLAY_NAME="${{ inputs.application_display_name || github.event.inputs.application_display_name || '' }}"

          # Export all inputs for use in subsequent steps
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "registry_server=$REGISTRY_SERVER" >> $GITHUB_OUTPUT
          echo "registry_namespace=$REGISTRY_NAMESPACE" >> $GITHUB_OUTPUT
          echo "docker_context=$DOCKER_CONTEXT" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
          echo "image_repository=$IMAGE_REPOSITORY" >> $GITHUB_OUTPUT
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "values_file_path=$VALUES_FILE_PATH" >> $GITHUB_OUTPUT
          echo "chart_repo_path=$CHART_REPO_PATH" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "git_user=$GIT_USER" >> $GITHUB_OUTPUT
          echo "git_email=$GIT_EMAIL" >> $GITHUB_OUTPUT
          echo "devops_repo=$DEVOPS_REPO" >> $GITHUB_OUTPUT
          echo "setup_databases=$SETUP_DATABASES" >> $GITHUB_OUTPUT
          echo "db_types=$DB_TYPES" >> $GITHUB_OUTPUT
          echo "env_secret_name=$ENV_SECRET_NAME" >> $GITHUB_OUTPUT
          echo "provider=$PROVIDER" >> $GITHUB_OUTPUT
          echo "contabo_api=$CONTABO_API" >> $GITHUB_OUTPUT
          echo "contabo_instance_id=$CONTABO_INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "contabo_ip=$CONTABO_IP" >> $GITHUB_OUTPUT
          echo "contabo_datacenter=$CONTABO_DATACENTER" >> $GITHUB_OUTPUT
          echo "contabo_region=$CONTABO_REGION" >> $GITHUB_OUTPUT
          echo "ssh_deploy=$SSH_DEPLOY" >> $GITHUB_OUTPUT
          echo "ssh_host=$SSH_HOST" >> $GITHUB_OUTPUT
          echo "ssh_user=$SSH_USER" >> $GITHUB_OUTPUT
          echo "ssh_port=$SSH_PORT" >> $GITHUB_OUTPUT
          echo "skip_files=$SKIP_FILES" >> $GITHUB_OUTPUT
          echo "skip_fs_scan=$SKIP_FS_SCAN" >> $GITHUB_OUTPUT
          echo "deployment_summary_title=$DEPLOYMENT_SUMMARY_TITLE" >> $GITHUB_OUTPUT
          echo "deployment_success_message=$DEPLOYMENT_SUCCESS_MESSAGE" >> $GITHUB_OUTPUT
          echo "application_display_name=$APPLICATION_DISPLAY_NAME" >> $GITHUB_OUTPUT

          # Also set as environment variables for easier access
          echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV
          echo "REGISTRY_SERVER=$REGISTRY_SERVER" >> $GITHUB_ENV
          echo "REGISTRY_NAMESPACE=$REGISTRY_NAMESPACE" >> $GITHUB_ENV
          echo "DOCKER_CONTEXT=$DOCKER_CONTEXT" >> $GITHUB_ENV
          echo "DOCKERFILE=$DOCKERFILE" >> $GITHUB_ENV
          echo "IMAGE_REPOSITORY=$IMAGE_REPOSITORY" >> $GITHUB_ENV
          echo "DEPLOY=$DEPLOY" >> $GITHUB_ENV
          echo "VALUES_FILE_PATH=$VALUES_FILE_PATH" >> $GITHUB_ENV
          echo "CHART_REPO_PATH=$CHART_REPO_PATH" >> $GITHUB_ENV
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV
          echo "GIT_USER=$GIT_USER" >> $GITHUB_ENV
          echo "GIT_EMAIL=$GIT_EMAIL" >> $GITHUB_ENV
          echo "DEVOPS_REPO=$DEVOPS_REPO" >> $GITHUB_ENV
          echo "SETUP_DATABASES=$SETUP_DATABASES" >> $GITHUB_ENV
          echo "DB_TYPES=$DB_TYPES" >> $GITHUB_ENV
          echo "ENV_SECRET_NAME=$ENV_SECRET_NAME" >> $GITHUB_ENV
          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "CONTABO_API=$CONTABO_API" >> $GITHUB_ENV
          echo "CONTABO_INSTANCE_ID=$CONTABO_INSTANCE_ID" >> $GITHUB_ENV
          echo "CONTABO_IP=$CONTABO_IP" >> $GITHUB_ENV
          echo "CONTABO_DATACENTER=$CONTABO_DATACENTER" >> $GITHUB_ENV
          echo "CONTABO_REGION=$CONTABO_REGION" >> $GITHUB_ENV
          echo "SSH_DEPLOY=$SSH_DEPLOY" >> $GITHUB_ENV
          echo "SSH_HOST=$SSH_HOST" >> $GITHUB_ENV
          echo "SSH_USER=$SSH_USER" >> $GITHUB_ENV
          echo "SSH_PORT=$SSH_PORT" >> $GITHUB_ENV
          echo "SSH_DEPLOY_COMMAND=$SSH_DEPLOY_COMMAND" >> $GITHUB_ENV
          echo "SKIP_FILES=$SKIP_FILES" >> $GITHUB_ENV
          echo "SKIP_FS_SCAN=$SKIP_FS_SCAN" >> $GITHUB_ENV
          echo "DEPLOYMENT_SUMMARY_TITLE=$DEPLOYMENT_SUMMARY_TITLE" >> $GITHUB_ENV
          echo "DEPLOYMENT_SUCCESS_MESSAGE=$DEPLOYMENT_SUCCESS_MESSAGE" >> $GITHUB_ENV
          echo "APPLICATION_DISPLAY_NAME=$APPLICATION_DISPLAY_NAME" >> $GITHUB_ENV

      - name: Configure SSH for build secrets (optional)
        env:
          SSH_PRIV: ${{ secrets.SSH_PRIVATE_KEY }}
          DOCKER_SSH_KEY_B64: ${{ secrets.DOCKER_SSH_KEY }}
        run: |
          mkdir -p -m 0700 $HOME/.ssh

          # Check if SSH keys are available
          USE_SSH=false
          if [ -n "${DOCKER_SSH_KEY_B64:-}" ] && [ "$DOCKER_SSH_KEY_B64" != "" ]; then
            echo "Found DOCKER_SSH_KEY, will use SSH for builds"
            USE_SSH=true
          elif [ -n "${SSH_PRIV:-}" ] && [ "$SSH_PRIV" != "" ]; then
            echo "Found SSH_PRIVATE_KEY, will use SSH for builds"
            USE_SSH=true
          fi

          if [ "$USE_SSH" = "true" ]; then
            if [ -n "${DOCKER_SSH_KEY_B64:-}" ] && [ "$DOCKER_SSH_KEY_B64" != "" ]; then
              echo "Loading DOCKER_SSH_KEY"
              echo "$DOCKER_SSH_KEY_B64" | base64 -d > $HOME/.ssh/id_rsa
            else
              echo "Loading SSH_PRIVATE_KEY as fallback"
              printf "%s" "$SSH_PRIV" > $HOME/.ssh/id_rsa
            fi
            chmod 0600 $HOME/.ssh/id_rsa
            ssh-keyscan github.com >> $HOME/.ssh/known_hosts 2>/dev/null || true
            eval "$(ssh-agent)"
            # Add SSH key with passphrase "codevertex" for automated deployments
            echo "codevertex" | SSH_ASKPASS=/bin/echo ssh-add $HOME/.ssh/id_rsa 2>/dev/null || {
              echo "‚ùå Failed to add SSH key to agent - passphrase may be incorrect"
              exit 1
            }
            echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
            echo "SSH configured successfully"
          else
            echo "No SSH keys found, will build without SSH"
            echo "SSH_AUTH_SOCK=" >> $GITHUB_ENV
          fi

      - name: Determine image repository
        id: img
        env:
          REG_SVR: ${{ steps.inputs.outputs.registry_server }}
          REG_NS: ${{ steps.inputs.outputs.registry_namespace }}
        run: |
          if [ -n "${{ steps.inputs.outputs.image_repository }}" ]; then
            echo "repo=${{ steps.inputs.outputs.image_repository }}" >> $GITHUB_OUTPUT
          else
            echo "repo=${REG_SVR}/${REG_NS}/${{ steps.inputs.outputs.app_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Log in to registry (optional)
        if: ${{ secrets.REGISTRY_USERNAME != '' && secrets.REGISTRY_PASSWORD != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ steps.inputs.outputs.registry_server }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Derive short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Install DevOps Tools
        uses: ./.github/actions/install-devops-tools

      - name: Trivy FS scan
        if: ${{ steps.inputs.outputs.skip_fs_scan != 'true' }}
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          scan-ref: .
          exit-code: '0'
          skip-files: "${{ steps.inputs.outputs.skip_files }}"

      - name: Build image (with SSH)
        if: ${{ env.SSH_AUTH_SOCK != '' && env.SSH_AUTH_SOCK != null }}
        run: |
          echo "üîë Building with SSH support"
          echo "üì¶ Image: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          DOCKER_BUILDKIT=1 docker build "${{ steps.inputs.outputs.docker_context }}" \
            -f "${{ steps.inputs.outputs.dockerfile }}" \
            -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}" \
            --ssh default="$SSH_AUTH_SOCK"

      - name: Build image (no SSH)
        if: ${{ env.SSH_AUTH_SOCK == '' || env.SSH_AUTH_SOCK == null }}
        run: |
          echo "üö´ Building without SSH (no keys configured)"
          echo "üì¶ Image: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          DOCKER_BUILDKIT=1 docker build "${{ steps.inputs.outputs.docker_context }}" \
            -f "${{ steps.inputs.outputs.dockerfile }}" \
            -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Trivy Image scan
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}
          exit-code: '0'

      - name: Push image
        if: ${{ steps.inputs.outputs.deploy }}
        run: docker push "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Setup databases (optional)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ steps.inputs.outputs.setup_databases }}
        timeout-minutes: 10
        continue-on-error: true
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          DB_TYPES: ${{ steps.inputs.outputs.db_types }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          set -e
          echo "Setting up databases in namespace ${NS}: ${DB_TYPES}"
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"

          # Tools
          sudo apt-get update -y && sudo apt-get install -y jq curl

          # Generate passwords if not provided
          gen_pwd() { openssl rand -hex 16; }
          : "${POSTGRES_PASSWORD:=$(gen_pwd)}"; : "${REDIS_PASSWORD:=$(gen_pwd)}"; : "${MONGO_PASSWORD:=$(gen_pwd)}"; : "${MYSQL_PASSWORD:=$(gen_pwd)}"

          echo "::group::Install Helm repos"
          helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>&1 || true
          helm repo update >/dev/null 2>&1 || true
          echo "::endgroup::"

          # Parse db types
          SAVEIFS=$IFS; IFS=','; set -f; types=($DB_TYPES); IFS=$SAVEIFS; set +f

          DB_SETUP_SUCCESS=0
          DB_SETUP_TOTAL=${#types[@]}

          for db in "${types[@]}"; do
            db=$(echo "$db" | xargs)
            echo "::group::Installing $db"

            case "$db" in
              postgres)
                echo "Installing PostgreSQL..."
                if helm upgrade --install postgresql bitnami/postgresql -n "$NS" \
                  --set global.postgresql.auth.postgresPassword="$POSTGRES_PASSWORD" \
                  --set global.postgresql.auth.database="appdb" \
                  --wait --timeout=300s; then
                  echo "‚úÖ PostgreSQL installed successfully"
                  export POSTGRES_URL="postgresql://postgres:${POSTGRES_PASSWORD}@postgresql.${NS}.svc.cluster.local:5432/appdb"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install PostgreSQL"
                fi
                ;;
              redis)
                echo "Installing Redis..."
                if helm upgrade --install redis bitnami/redis -n "$NS" \
                  --set global.redis.password="$REDIS_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "‚úÖ Redis installed successfully"
                  export REDIS_URL="redis://:${REDIS_PASSWORD}@redis-master.${NS}.svc.cluster.local:6379/0"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install Redis"
                fi
                ;;
              mongo|mongodb)
                echo "Installing MongoDB..."
                if helm upgrade --install mongodb bitnami/mongodb -n "$NS" \
                  --set auth.rootPassword="$MONGO_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "‚úÖ MongoDB installed successfully"
                  export MONGO_URL="mongodb://root:${MONGO_PASSWORD}@mongodb.${NS}.svc.cluster.local:27017/?authSource=admin"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install MongoDB"
                fi
                ;;
              mysql)
                echo "Installing MySQL..."
                if helm upgrade --install mysql bitnami/mysql -n "$NS" \
                  --set auth.rootPassword="$MYSQL_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "‚úÖ MySQL installed successfully"
                  export MYSQL_URL="mysql://root:${MYSQL_PASSWORD}@mysql.${NS}.svc.cluster.local:3306/appdb"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "‚ùå Failed to install MySQL"
                fi
                ;;
              *)
                echo "‚ö†Ô∏è Unknown database type: $db"
                ;;
            esac
            echo "::endgroup::"
          done

          echo "üìä Database setup summary: $DB_SETUP_SUCCESS/$DB_SETUP_TOTAL successful"

          # Create/update environment secret with database URLs
          echo "::group::Creating environment secret"
          LITS=""
          [ -n "$POSTGRES_URL" ] && LITS="$LITS --from-literal=DATABASE_URL=$POSTGRES_URL"
          [ -n "$REDIS_URL" ] && LITS="$LITS --from-literal=REDIS_URL=$REDIS_URL --from-literal=CELERY_BROKER_URL=$REDIS_URL --from-literal=CELERY_RESULT_BACKEND=$REDIS_URL"
          [ -n "$MONGO_URL" ] && LITS="$LITS --from-literal=MONGO_URL=$MONGO_URL"
          [ -n "$MYSQL_URL" ] && LITS="$LITS --from-literal=MYSQL_URL=$MYSQL_URL"

          if [ -n "$LITS" ]; then
            if kubectl -n "$NS" create secret generic "${{ steps.inputs.outputs.env_secret_name }}" $LITS --dry-run=client -o yaml | kubectl apply -f -; then
              echo "‚úÖ Environment secret created/updated successfully"
            else
              echo "‚ùå Failed to create/update environment secret"
            fi
          else
            echo "‚ÑπÔ∏è No database URLs were generated; skipping secret creation"
          fi
          echo "::endgroup::"

      - name: Contabo API bootstrap (ensure instance ready)
        id: contabo_bootstrap
        if: ${{ steps.inputs.outputs.deploy }} && ${{ steps.inputs.outputs.provider }} == 'contabo' && ${{ steps.inputs.outputs.contabo_api }}
        env:
          CLIENT_ID: ${{ secrets.CONTABO_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CONTABO_CLIENT_SECRET }}
          API_USER: ${{ secrets.CONTABO_API_USERNAME }}
          API_PASS: ${{ secrets.CONTABO_API_PASSWORD }}
          INSTANCE_ID: ${{ steps.inputs.outputs.contabo_instance_id }}
        run: |
          if [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ] || [ -z "$API_USER" ] || [ -z "$API_PASS" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Missing Contabo API credentials or instance id, will rely on SSH fallback if enabled"; exit 0; fi
          sudo apt-get update -y && sudo apt-get install -y jq curl
          TOKEN=$(curl -s -X POST https://auth.contabo.com/oauth2/token \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            -d "grant_type=password&username=${API_USER}&password=${API_PASS}&client_id=${CLIENT_ID}&client_secret=${CLIENT_SECRET}&scope=openid")
          ACCESS_TOKEN=$(echo "$TOKEN" | jq -r '.access_token')
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then echo "Failed to acquire Contabo token"; exit 0; fi
          INFO=$(curl -s -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID)
          STATUS=$(echo "$INFO" | jq -r '.status // .data[0].status')
          IP=$(echo "$INFO" | jq -r '.publicIpConfig.ip || .data[0].publicIpConfig.ip')
          echo "Contabo instance status: $STATUS, ip: $IP"
          echo "contabo_ip=$IP" >> $GITHUB_OUTPUT
          # Optionally ensure instance is powered on
          if [ "$STATUS" != "running" ] && [ "$STATUS" != "ACTIVE" ]; then
            curl -s -X POST -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID/start || true
          fi

      - name: Update values in devops-k8s
        if: ${{ steps.inputs.outputs.deploy }}
        timeout-minutes: 5
        env:
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
          VALUES_PATH: ${{ steps.inputs.outputs.values_file_path }}
          IMAGE_REPO: ${{ steps.img.outputs.repo }}
          DEVOPS_REPO: ${{ steps.inputs.outputs.devops_repo }}
          GIT_USER: ${{ steps.inputs.outputs.git_user }}
          GIT_EMAIL: ${{ steps.inputs.outputs.git_email }}
        run: |
          # Ensure SSH is configured for git operations
          if [ -n "${SSH_AUTH_SOCK:-}" ] && [ "$SSH_AUTH_SOCK" != "" ]; then
            echo "üîë Using SSH for git operations"
            export SSH_AUTH_SOCK="$SSH_AUTH_SOCK"

            # Create SSH config file for reliable git operations
            mkdir -p ~/.ssh
            cat > ~/.ssh/config << 'EOF'
            Host github.com
                HostName github.com
                User git
                IdentitiesOnly yes
                StrictHostKeyChecking no
            EOF
            chmod 600 ~/.ssh/config

            # Set SSH key path for git operations
            if [ -n "${DOCKER_SSH_KEY_B64:-}" ]; then
              echo "Using DOCKER_SSH_KEY for git operations"
              echo "$DOCKER_SSH_KEY_B64" | base64 -d > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            elif [ -n "${SSH_PRIV:-}" ]; then
              echo "Using SSH_PRIVATE_KEY for git operations"
              printf "%s" "$SSH_PRIV" > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            fi

            echo "‚úÖ SSH configured for git operations"
          else
            echo "‚ö†Ô∏è SSH not configured, git operations may fail"
          fi

          git config user.name "$GIT_USER"
          git config user.email "$GIT_EMAIL"

          # Retry git operations with exponential backoff
          max_retries=3
          for ((i=1; i<=max_retries; i++)); do
            echo "üîÑ Git operation attempt $i/$max_retries"

            if git pull --rebase; then
              echo "‚úÖ Git pull successful"
              break
            else
              echo "‚ùå Git pull failed (attempt $i/$max_retries)"
              if [ $i -eq $max_retries ]; then
                echo "üí• All git pull attempts failed, continuing with local repo"
                break
              fi
              sleep $((2 ** (i-1)))  # Exponential backoff: 1s, 2s, 4s
            fi
          done

          # Update Helm values
          if [ -f "$VALUES_PATH" ]; then
            echo "üìù Updating Helm values: $VALUES_PATH"
            yq -yi ".image.repository = \"${IMAGE_REPO}\" | .image.tag = \"${SHORT_SHA}\"" "${VALUES_PATH}"

            if [ $? -eq 0 ]; then
              echo "‚úÖ Helm values updated successfully"

              # Check if there are changes to commit
              if git diff --quiet HEAD "${VALUES_PATH}"; then
                echo "‚ÑπÔ∏è No changes to commit"
              else
                echo "üíæ Committing changes"
                git add "${VALUES_PATH}"

                # Retry git commit
                if git commit -m "${{ steps.inputs.outputs.app_name }}:${SHORT_SHA} released"; then
                  echo "‚úÖ Changes committed"

                  # Retry git push with exponential backoff
                  push_max_retries=3
                  for ((j=1; j<=push_max_retries; j++)); do
                    echo "üîÑ Git push attempt $j/$push_max_retries"
                    if git push; then
                      echo "‚úÖ Git push successful"
                      break
                    else
                      echo "‚ùå Git push failed (attempt $j/$push_max_retries)"
                      if [ $j -eq $push_max_retries ]; then
                        echo "üí• All git push attempts failed"
                        echo "‚ö†Ô∏è Deployment will continue despite git push failure"
                      fi
                      sleep $((2 ** (j-1)))
                    fi
                  done
                else
                  echo "‚ùå Git commit failed"
                fi
              fi
            else
              echo "‚ùå Failed to update Helm values"
            fi
          else
            echo "‚ö†Ô∏è Helm values file not found: $VALUES_PATH"
          fi

      - name: Apply kube secrets (optional)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ secrets.KUBE_CONFIG }} != ''
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"
          if [ -f kubeSecrets/devENV.yaml ]; then
            kubectl apply -f kubeSecrets/devENV.yaml || true
          fi

      - name: Ensure default JWT secret (when KUBE_CONFIG provided)
        if: ${{ steps.inputs.outputs.deploy }} && ${{ secrets.KUBE_CONFIG }} != ''
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          SECRET_NAME: ${{ steps.inputs.outputs.env_secret_name }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -e
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"
          JWT=$(openssl rand -hex 32)
          if kubectl -n "$NS" get secret "$SECRET_NAME" >/dev/null 2>&1; then
            # Patch only if key missing
            if ! kubectl -n "$NS" get secret "$SECRET_NAME" -o jsonpath='{.data.JWT_SECRET}' >/dev/null 2>&1; then
              kubectl -n "$NS" patch secret "$SECRET_NAME" -p "{\"stringData\":{\"JWT_SECRET\":\"$JWT\"}}"
            fi
          else
            kubectl -n "$NS" create secret generic "$SECRET_NAME" --from-literal=JWT_SECRET="$JWT"
          fi

      - name: SSH deploy to VPS (optional)
        if: ${{ steps.inputs.outputs.ssh_deploy }} || (${{ steps.inputs.outputs.provider }} == 'contabo' && ${{ steps.inputs.outputs.contabo_api }} && ${{ steps.vars.outputs.short_sha }} != '' )
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ steps.inputs.outputs.ssh_host || steps.inputs.outputs.contabo_ip || steps.contabo_bootstrap.outputs.contabo_ip }}
          username: ${{ steps.inputs.outputs.ssh_user }}
          port: ${{ steps.inputs.outputs.ssh_port }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            echo "Logging into registry"
            echo '${{ secrets.REGISTRY_PASSWORD }}' | docker login ${{ steps.inputs.outputs.registry_server }} -u '${{ secrets.REGISTRY_USERNAME }}' --password-stdin || true
            echo "Pulling image"
            docker pull "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
            echo "Restarting container"
            docker rm -f ${{ steps.inputs.outputs.app_name }} || true
            docker run -d --restart always --name ${{ steps.inputs.outputs.app_name }} -p 0.0.0.0:80:80 "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Get service URLs
        id: service_urls
        if: ${{ steps.inputs.outputs.deploy }} && ${{ secrets.KUBE_CONFIG }} != ''
        env:
          NS: ${{ steps.inputs.outputs.namespace }}
          APP_NAME: ${{ steps.inputs.outputs.app_name }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          
          # Wait for services to be ready and discover URLs
          echo "üîç Discovering service URLs..."

          urls=""
          max_wait_time=300  # 5 minutes timeout
          wait_interval=15   # Check every 15 seconds
          elapsed_time=0

          while [[ $elapsed_time -lt $max_wait_time ]]; do
            echo "‚è≥ Waiting for services to be ready... (${elapsed_time}s/${max_wait_time}s)"

            # Get ingress URLs for the application
            if kubectl get ingress -n "$NS" >/dev/null 2>&1; then
              while IFS= read -r ingress; do
                if [[ -n "$ingress" ]]; then
                  # Extract host from ingress
                  host=$(kubectl get ingress "$ingress" -n "$NS" -o jsonpath='{.spec.rules[0].host}' 2>/dev/null)

                  if [[ -n "$host" ]]; then
                    # Determine protocol (default to http, but check for TLS)
                    protocol="http"
                    if kubectl get ingress "$ingress" -n "$NS" -o jsonpath='{.spec.tls}' 2>/dev/null | grep -q "hosts"; then
                      protocol="https"
                    fi

                    urls="${urls}${protocol}://${host}\n"
                    echo "‚úÖ Found ingress URL: ${protocol}://${host}"
                  fi
                fi
              done < <(kubectl get ingress -n "$NS" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)
            fi

            # If no ingress URLs found, try to get service URLs
            if [[ -z "$urls" ]]; then
              if kubectl get svc "$APP_NAME" -n "$NS" >/dev/null 2>&1; then
                service_port=$(kubectl get svc "$APP_NAME" -n "$NS" -o jsonpath='{.spec.ports[0].port}' 2>/dev/null)

                if [[ -n "$service_port" ]]; then
                  # Check if service is ready (has endpoints)
                  if kubectl get endpoints "$APP_NAME" -n "$NS" -o jsonpath='{.subsets[*].addresses}' 2>/dev/null | grep -q "ip"; then
                    urls="http://${APP_NAME}.${NS}.svc.cluster.local:${service_port}\n"
                    urls="${urls}(Cluster internal URL - configure ingress for external access)"
                    echo "‚úÖ Found service URL: http://${APP_NAME}.${NS}.svc.cluster.local:${service_port}"
                  fi
                fi
              fi
            fi

            # If we found URLs, break out of the waiting loop
            if [[ -n "$urls" ]]; then
              echo "üéâ Service URLs discovered successfully!"
              break
            fi

            # Wait before next check
            sleep $wait_interval
            elapsed_time=$((elapsed_time + wait_interval))
          done

          # Final status report
          if [[ -n "$urls" ]]; then
            echo "‚úÖ Service URLs discovered after ${elapsed_time}s:"
            echo -e "$urls"
          else
            echo "‚ö†Ô∏è No service URLs found after ${max_wait_time}s timeout"
            echo "üîß Services may still be starting up - check ArgoCD sync status"
            urls="‚è≥ Services still starting up...\nCheck ArgoCD for sync status"
          fi

          echo "service_urls<<EOF" >> $GITHUB_OUTPUT
          echo -e "$urls" | sed '/^$/d' | head -5 >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # Add cleanup step to ensure no leftover processes or files
      - name: Cleanup temporary files
        if: always()
        run: |
          # Clean up any temporary files and stop background processes
          rm -rf $HOME/.ssh/id_rsa* 2>/dev/null || true
          rm -f /tmp/migrate-job.yaml 2>/dev/null || true
          # Kill any hanging kubectl processes
          pkill -f kubectl || true

          # Database information if setup was enabled
          if [[ "${{ steps.inputs.outputs.setup_databases }}" == "true" ]]; then
            echo "### üóÑÔ∏è Database Setup" >> $GITHUB_STEP_SUMMARY
            echo "- **Databases:** ${{ steps.inputs.outputs.db_types }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Secret:** ${{ steps.inputs.outputs.env_secret_name }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Namespace:** ${{ steps.inputs.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### üìã Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. **Verify ArgoCD Sync:** Check that ArgoCD has synced the new image tag" >> $GITHUB_STEP_SUMMARY
          echo "2. **Test Application:** Access the service URLs listed above" >> $GITHUB_STEP_SUMMARY
          echo "3. **Monitor Logs:** Check application and database logs for any issues" >> $GITHUB_STEP_SUMMARY
          echo "4. **SSL Certificate:** Configure ingress with SSL certificate for HTTPS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### üîß Useful Commands" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Check ArgoCD sync status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get applications -n argocd" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check application logs" >> $GITHUB_STEP_SUMMARY
          echo "kubectl logs -l app=${{ steps.inputs.outputs.app_name }} -n ${{ steps.inputs.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check service status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods,svc,ingress -l app=${{ steps.inputs.outputs.app_name }} -n ${{ steps.inputs.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "üéâ **${{ steps.inputs.outputs.deployment_success_message }}**" >> $GITHUB_STEP_SUMMARY

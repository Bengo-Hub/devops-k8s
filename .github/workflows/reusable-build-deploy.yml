name: Reusable Build and Deploy

on:
  workflow_call:
    inputs:
      app_name:
        required: true
        type: string
      registry_server:
        required: false
        type: string
        default: docker.io
      registry_namespace:
        required: false
        type: string
        default: codevertex
      docker_context:
        required: false
        type: string
        default: .
      dockerfile:
        required: false
        type: string
        default: Dockerfile
      image_repository:
        required: false
        type: string
      deploy:
        required: false
        type: boolean
        default: false
      values_file_path:
        required: true
        type: string
      chart_repo_path:
        required: false
        type: string
        default: charts/app
      namespace:
        required: false
        type: string
        default: default
      # Database automation (optional)
      setup_databases:
        required: false
        type: boolean
        default: false
      db_types:
        description: "Comma-separated list of databases to setup (postgres,redis,mongo,mysql)"
        required: false
        type: string
        default: "postgres,redis"
      env_secret_name:
        description: "Kubernetes Secret name to create/update with DB URLs"
        required: false
        type: string
        default: "app-env"
      provider:
        required: false
        type: string
        default: contabo
      contabo_api:
        required: false
        type: boolean
        default: true
      contabo_instance_id:
        required: false
        type: string
        default: "202846760"
      contabo_ip:
        required: false
        type: string
        default: "77.237.232.66"
      contabo_datacenter:
        required: false
        type: string
        default: "European Union 2"
      contabo_region:
        required: false
        type: string
        default: "EU"
      ssh_deploy:
        required: false
        type: boolean
        default: false
      ssh_host:
        required: false
        type: string
      ssh_user:
        required: false
        type: string
      ssh_port:
        required: false
        type: string
        default: "22"
      ssh_deploy_command:
        required: false
        type: string
    secrets:
      REGISTRY_USERNAME:
        required: false
      REGISTRY_PASSWORD:
        required: false
      KUBE_CONFIG:
        required: false
      SSH_PRIVATE_KEY:
        required: false
      DOCKER_SSH_KEY:
        required: false
      # Optional DB credentials (auto-generated if not provided)
      POSTGRES_PASSWORD:
        required: false
      REDIS_PASSWORD:
        required: false
      MONGO_PASSWORD:
        required: false
      MYSQL_PASSWORD:
        required: false
      CONTABO_CLIENT_ID:
        required: false
      CONTABO_CLIENT_SECRET:
        required: false
      CONTABO_API_USERNAME:
        required: false
      CONTABO_API_PASSWORD:
        required: false

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      REG_USER: ${{ secrets.REGISTRY_USERNAME }}
      REG_PASS: ${{ secrets.REGISTRY_PASSWORD }}
      KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
      DOCKER_SSH_KEY_B64: ${{ secrets.DOCKER_SSH_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure SSH for build secrets (optional)
        env:
          SSH_PRIV: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p -m 0700 $HOME/.ssh
          if [ -n "${DOCKER_SSH_KEY_B64:-}" ]; then
            echo "$DOCKER_SSH_KEY_B64" | base64 -d > $HOME/.ssh/id_rsa
            echo "Loaded DOCKER_SSH_KEY"
          elif [ -n "${SSH_PRIV:-}" ]; then
            printf "%s" "$SSH_PRIV" > $HOME/.ssh/id_rsa
            echo "Loaded SSH_PRIVATE_KEY as fallback for Docker build"
          else
            echo "No SSH key provided; skipping SSH agent setup"
            exit 0
          fi
          chmod 0600 $HOME/.ssh/id_rsa
          ssh-keyscan github.com >> $HOME/.ssh/known_hosts 2>/dev/null || true
          eval "$(ssh-agent)"
          ssh-add $HOME/.ssh/id_rsa
          # Persist SSH agent socket for later steps
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV

      - name: Determine image repository
        id: img
        env:
          REG_SVR: ${{ inputs.registry_server }}
          REG_NS: ${{ inputs.registry_namespace }}
        run: |
          if [ -n "${{ inputs.image_repository }}" ]; then
            echo "repo=${{ inputs.image_repository }}" >> $GITHUB_OUTPUT
          else
            echo "repo=${REG_SVR}/${REG_NS}/${{ inputs.app_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Log in to registry (optional)
        if: ${{ env.REG_USER != '' && env.REG_PASS != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry_server }}
          username: ${{ env.REG_USER }}
          password: ${{ env.REG_PASS }}

      - name: Derive short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl
          sudo curl -L "https://github.com/mikefarah/yq/releases/download/v4.44.3/yq_linux_amd64" -o /usr/local/bin/yq && sudo chmod +x /usr/local/bin/yq

      - name: Trivy FS scan
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          scan-ref: .
          exit-code: '0'

      - name: Build image
        run: |
          if [ -n "${SSH_AUTH_SOCK:-}" ]; then
            echo "Using SSH agent for Docker build"
            DOCKER_BUILDKIT=1 docker build "${{ inputs.docker_context }}" \
              -f "${{ inputs.dockerfile }}" \
              -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}" \
              --ssh default=$SSH_AUTH_SOCK
          else
            echo "No SSH agent available; building without --ssh"
            DOCKER_BUILDKIT=1 docker build "${{ inputs.dockerfile == 'Dockerfile' && inputs.docker_context || inputs.docker_context }}" \
              -f "${{ inputs.dockerfile }}" \
              -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          fi

      - name: Trivy Image scan
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}
          exit-code: '0'

      - name: Push image
        if: ${{ inputs.deploy }}
        run: docker push "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Setup databases (optional)
        if: ${{ inputs.deploy && inputs.setup_databases }}
        env:
          NS: ${{ inputs.namespace }}
          DB_TYPES: ${{ inputs.db_types }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          set -e
          echo "Setting up databases in namespace ${NS}: ${DB_TYPES}"
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"
          # Tools
          sudo apt-get update -y && sudo apt-get install -y jq curl
          # Generate passwords if not provided
          gen_pwd() { openssl rand -hex 16; }
          : "${POSTGRES_PASSWORD:=$(gen_pwd)}"; : "${REDIS_PASSWORD:=$(gen_pwd)}"; : "${MONGO_PASSWORD:=$(gen_pwd)}"; : "${MYSQL_PASSWORD:=$(gen_pwd)}"
          echo "::group::Install Helm repos"
          helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>&1 || true
          helm repo update >/dev/null 2>&1 || true
          echo "::endgroup::"
          # Parse db types
          SAVEIFS=$IFS; IFS=','; set -f; types=($DB_TYPES); IFS=$SAVEIFS; set +f
          for db in "${types[@]}"; do
            db=$(echo "$db" | xargs)
            if [ "$db" = "postgres" ]; then
              echo "Installing PostgreSQL..."
              helm upgrade --install postgresql bitnami/postgresql -n "$NS" \
                --set global.postgresql.auth.postgresPassword="$POSTGRES_PASSWORD" \
                --set global.postgresql.auth.database="appdb" \
                --wait
              export POSTGRES_URL="postgresql://postgres:${POSTGRES_PASSWORD}@postgresql.${NS}.svc.cluster.local:5432/appdb"
            elif [ "$db" = "redis" ]; then
              echo "Installing Redis..."
              helm upgrade --install redis bitnami/redis -n "$NS" \
                --set global.redis.password="$REDIS_PASSWORD" \
                --wait
              export REDIS_URL="redis://:${REDIS_PASSWORD}@redis-master.${NS}.svc.cluster.local:6379/0"
            elif [ "$db" = "mongo" ] || [ "$db" = "mongodb" ]; then
              echo "Installing MongoDB..."
              helm upgrade --install mongodb bitnami/mongodb -n "$NS" \
                --set auth.rootPassword="$MONGO_PASSWORD" \
                --wait
              export MONGO_URL="mongodb://root:${MONGO_PASSWORD}@mongodb.${NS}.svc.cluster.local:27017/?authSource=admin"
            elif [ "$db" = "mysql" ]; then
              echo "Installing MySQL..."
              helm upgrade --install mysql bitnami/mysql -n "$NS" \
                --set auth.rootPassword="$MYSQL_PASSWORD" \
                --wait
              export MYSQL_URL="mysql://root:${MYSQL_PASSWORD}@mysql.${NS}.svc.cluster.local:3306/appdb"
            fi
          done
          echo "Creating/updating env secret ${NS}/${{ inputs.env_secret_name }}"
          # Build literals dynamically
          LITS=""
          [ -n "$POSTGRES_URL" ] && LITS="$LITS --from-literal=DATABASE_URL=$POSTGRES_URL"
          [ -n "$REDIS_URL" ] && LITS="$LITS --from-literal=REDIS_URL=$REDIS_URL --from-literal=CELERY_BROKER_URL=$REDIS_URL --from-literal=CELERY_RESULT_BACKEND=$REDIS_URL"
          [ -n "$MONGO_URL" ] && LITS="$LITS --from-literal=MONGO_URL=$MONGO_URL"
          [ -n "$MYSQL_URL" ] && LITS="$LITS --from-literal=MYSQL_URL=$MYSQL_URL"
          if [ -n "$LITS" ]; then
            kubectl -n "$NS" create secret generic "${{ inputs.env_secret_name }}" $LITS --dry-run=client -o yaml | kubectl apply -f -
          else
            echo "No DB URLs were generated; skipping secret creation"
          fi

      - name: Contabo API bootstrap (ensure instance ready)
        id: contabo_bootstrap
        if: ${{ inputs.deploy && inputs.provider == 'contabo' && inputs.contabo_api }}
        env:
          CLIENT_ID: ${{ secrets.CONTABO_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CONTABO_CLIENT_SECRET }}
          API_USER: ${{ secrets.CONTABO_API_USERNAME }}
          API_PASS: ${{ secrets.CONTABO_API_PASSWORD }}
          INSTANCE_ID: ${{ inputs.contabo_instance_id }}
        run: |
          if [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ] || [ -z "$API_USER" ] || [ -z "$API_PASS" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Missing Contabo API credentials or instance id, will rely on SSH fallback if enabled"; exit 0; fi
          sudo apt-get update -y && sudo apt-get install -y jq curl
          TOKEN=$(curl -s -X POST https://auth.contabo.com/oauth2/token \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            -d "grant_type=password&username=${API_USER}&password=${API_PASS}&client_id=${CLIENT_ID}&client_secret=${CLIENT_SECRET}&scope=openid")
          ACCESS_TOKEN=$(echo "$TOKEN" | jq -r '.access_token')
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then echo "Failed to acquire Contabo token"; exit 0; fi
          INFO=$(curl -s -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID)
          STATUS=$(echo "$INFO" | jq -r '.status // .data[0].status')
          IP=$(echo "$INFO" | jq -r '.publicIpConfig.ip || .data[0].publicIpConfig.ip')
          echo "Contabo instance status: $STATUS, ip: $IP"
          echo "contabo_ip=$IP" >> $GITHUB_OUTPUT
          # Optionally ensure instance is powered on
          if [ "$STATUS" != "running" ] && [ "$STATUS" != "ACTIVE" ]; then
            curl -s -X POST -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID/start || true
          fi

      - name: Update values in devops-k8s
        if: ${{ inputs.deploy }}
        env:
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
          VALUES_PATH: ${{ inputs.values_file_path }}
          IMAGE_REPO: ${{ steps.img.outputs.repo }}
        run: |
          git config user.name "DevOps Bot"
          git config user.email "devops@bot.local"
          git pull --rebase
          yq -yi ".image.repository = \"${IMAGE_REPO}\" | .image.tag = \"${SHORT_SHA}\"" "${VALUES_PATH}"
          git add "${VALUES_PATH}"
          git commit -m "${{ inputs.app_name }}:${SHORT_SHA} released" || echo "No changes"
          git push

      - name: Apply kube secrets (optional)
        if: ${{ inputs.deploy && env.KUBE_CONFIG_B64 != '' }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "${{ inputs.namespace }}" >/dev/null 2>&1 || kubectl create ns "${{ inputs.namespace }}"
          if [ -f kubeSecrets/devENV.yaml ]; then
            kubectl apply -f kubeSecrets/devENV.yaml || true
          fi

      - name: Ensure default JWT secret (when KUBE_CONFIG provided)
        if: ${{ inputs.deploy && env.KUBE_CONFIG_B64 != '' }}
        env:
          NS: ${{ inputs.namespace }}
          SECRET_NAME: ${{ inputs.env_secret_name }}
        run: |
          set -e
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"
          JWT=$(openssl rand -hex 32)
          if kubectl -n "$NS" get secret "$SECRET_NAME" >/dev/null 2>&1; then
            # Patch only if key missing
            if ! kubectl -n "$NS" get secret "$SECRET_NAME" -o jsonpath='{.data.JWT_SECRET}' >/dev/null 2>&1; then
              kubectl -n "$NS" patch secret "$SECRET_NAME" -p "{\"stringData\":{\"JWT_SECRET\":\"$JWT\"}}"
            fi
          else
            kubectl -n "$NS" create secret generic "$SECRET_NAME" --from-literal=JWT_SECRET="$JWT"
          fi

      - name: Run database migrations (Django apps)
        if: ${{ inputs.deploy && env.KUBE_CONFIG_B64 != '' && inputs.app_name == 'erp-api' }}
        env:
          NS: ${{ inputs.namespace }}
          IMAGE_REPO: ${{ steps.img.outputs.repo }}
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
        run: |
          echo "::group::Running database migrations"
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          
          # Create migration job
          cat > /tmp/migrate-job.yaml <<EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: erp-migrate-${{ steps.vars.outputs.short_sha }}
            namespace: ${NS}
          spec:
            ttlSecondsAfterFinished: 600
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: migrate
                  image: ${IMAGE_REPO}:${SHORT_SHA}
                  command: ["python", "manage.py", "migrate"]
                  envFrom:
                  - secretRef:
                      name: ${{ inputs.env_secret_name }}
          EOF
          
          kubectl apply -f /tmp/migrate-job.yaml
          kubectl wait --for=condition=complete job/erp-migrate-${{ steps.vars.outputs.short_sha }} -n ${NS} --timeout=300s || {
            echo "Migration job logs:"
            kubectl logs job/erp-migrate-${{ steps.vars.outputs.short_sha }} -n ${NS} || true
            exit 1
          }
          echo "✅ Database migrations completed"
          echo "::endgroup::"

      - name: SSH deploy to VPS (optional)
        if: ${{ inputs.ssh_deploy || (inputs.provider == 'contabo' && inputs.contabo_api && steps.vars.outputs.short_sha != '' ) }}
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ inputs.ssh_host || inputs.contabo_ip || steps.contabo_bootstrap.outputs.contabo_ip }}
          username: ${{ inputs.ssh_user }}
          port: ${{ inputs.ssh_port }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            echo "Logging into registry"
            echo '${{ secrets.REGISTRY_PASSWORD }}' | docker login ${{ inputs.registry_server }} -u '${{ secrets.REGISTRY_USERNAME }}' --password-stdin || true
            echo "Pulling image"
            docker pull "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
            echo "Restarting container"
            docker rm -f ${{ inputs.app_name }} || true
            docker run -d --restart always --name ${{ inputs.app_name }} -p 0.0.0.0:80:80 "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"



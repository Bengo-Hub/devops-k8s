name: Reusable Build and Deploy

on:
  workflow_call:
    inputs:
      # Generic branding and customization
      deployment_summary_title:
        required: false
        type: string
        default: "Deployment Summary"
        description: "Title for the deployment summary (e.g., 'MyApp Deployment Summary')"
      deployment_success_message:
        required: false
        type: string
        default: "Deployment completed! Application should be accessible via the URLs above."
        description: "Success message displayed in deployment summary"
      application_display_name:
        required: false
        type: string
        description: "Human-readable application name for display (defaults to app_name)"

      # Core deployment parameters
      app_name:
        required: true
        type: string
        description: "Application name (required, used for naming resources and ArgoCD applications)"
      registry_server:
        required: false
        type: string
        default: docker.io
        description: "Container registry server (e.g., docker.io, gcr.io, quay.io)"
      registry_namespace:
        required: false
        type: string
        default: codevertex
        description: "Registry namespace/organization (e.g., codevertex, myorg)"
      docker_context:
        required: false
        type: string
        default: .
        description: "Docker build context path (relative to repository root)"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
        description: "Path to Dockerfile (relative to docker_context)"
      image_repository:
        required: false
        type: string
        description: "Custom image repository (overrides registry_server/namespace/app_name)"
      deploy:
        required: false
        type: boolean
        default: false
        description: "Enable deployment phase (build, push, and deploy)"
      values_file_path:
        required: true
        type: string
        description: "Path to Helm values file in devops-k8s repository (e.g., apps/erp-api/values.yaml)"
      chart_repo_path:
        required: false
        type: string
        default: charts/app
        description: "Path to Helm chart in devops-k8s repository"
      namespace:
        required: false
        type: string
        default: default
        description: "Kubernetes namespace for deployment (must exist or be creatable)"
      # Git configuration for devops-k8s repo access
      git_user:
        required: false
        type: string
        default: "Titus Owuor"
        description: "Git commit author name for devops-k8s repository updates"
      git_email:
        required: false
        type: string
        default: "titusowuor30@gmail.com"
        description: "Git commit author email for devops-k8s repository updates"
      devops_repo:
        required: false
        type: string
        default: "Bengo-Hub/devops-k8s"
        description: "DevOps repository in format 'owner/repo' for Helm updates"
      # Database automation (optional)
      setup_databases:
        required: false
        type: boolean
        default: false
        description: "Enable automatic database setup (postgres, redis, mongo, mysql)"
      db_types:
        description: "Comma-separated list of databases to setup (postgres,redis,mongo,mysql)"
        required: false
        type: string
        default: "postgres,redis"
      env_secret_name:
        description: "Kubernetes Secret name to create/update with DB URLs"
        required: false
        type: string
        default: "app-env"
      provider:
        required: false
        type: string
        default: contabo
        description: "Cloud provider (contabo, aws, gcp, azure)"
      contabo_api:
        required: false
        type: boolean
        default: true
        description: "Enable Contabo API for instance management"
      contabo_instance_id:
        required: false
        type: string
        default: "202846760"
        description: "Contabo instance ID for API operations"
      contabo_ip:
        required: false
        type: string
        default: "77.237.232.66"
        description: "Contabo instance IP address"
      contabo_datacenter:
        required: false
        type: string
        default: "European Union 2"
        description: "Contabo datacenter location"
      contabo_region:
        required: false
        type: string
        default: "EU"
        description: "Contabo region (EU, US, etc.)"
      ssh_deploy:
        required: false
        type: boolean
        default: false
        description: "Enable SSH deployment to VPS"
      ssh_host:
        required: false
        type: string
        description: "SSH target host (IP or hostname)"
      ssh_user:
        required: false
        type: string
        description: "SSH username for deployment"
      ssh_port:
        required: false
        type: string
        default: "22"
        description: "SSH port (default: 22)"
      ssh_deploy_command:
        required: false
        type: string
        description: "Custom SSH deployment command"

  # Allow manual triggering for testing and direct execution
  workflow_dispatch:
    inputs:
      # Generic branding and customization
      deployment_summary_title:
        required: false
        type: string
        default: "Deployment Summary"
        description: "Title for the deployment summary"
      deployment_success_message:
        required: false
        type: string
        default: "Deployment completed! Application should be accessible via the URLs above."
        description: "Success message displayed in deployment summary"
      application_display_name:
        required: false
        type: string
        description: "Human-readable application name for display"

      # Core deployment parameters
      app_name:
        required: true
        type: string
        description: "Application name (used for naming resources)"
      registry_server:
        required: false
        type: string
        default: docker.io
        description: "Container registry server"
      registry_namespace:
        required: false
        type: string
        default: codevertex
        description: "Registry namespace/organization"
      docker_context:
        required: false
        type: string
        default: .
        description: "Docker build context path"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
        description: "Path to Dockerfile"
      image_repository:
        required: false
        type: string
        description: "Custom image repository"
      deploy:
        required: false
        type: boolean
        default: false
        description: "Enable deployment phase"
      values_file_path:
        required: true
        type: string
        description: "Path to Helm values file"
      chart_repo_path:
        required: false
        type: string
        default: charts/app
        description: "Path to Helm chart"
      namespace:
        required: false
        type: string
        default: default
        description: "Kubernetes namespace"
      git_user:
        required: false
        type: string
        default: "Titus Owuor"
        description: "Git commit author name"
      git_email:
        required: false
        type: string
        default: "titusowuor30@gmail.com"
        description: "Git commit author email"
      devops_repo:
        required: false
        type: string
        default: "Bengo-Hub/devops-k8s"
        description: "DevOps repository"
      setup_databases:
        required: false
        type: boolean
        default: false
        description: "Enable database setup"
      db_types:
        required: false
        type: string
        default: "postgres,redis"
        description: "Database types to setup"
      env_secret_name:
        required: false
        type: string
        default: "app-env"
        description: "Environment secret name"
      provider:
        required: false
        type: string
        default: contabo
        description: "Cloud provider"
      contabo_api:
        required: false
        type: boolean
        default: true
        description: "Enable Contabo API"
      contabo_instance_id:
        required: false
        type: string
        default: "202846760"
        description: "Contabo instance ID"
      contabo_ip:
        required: false
        type: string
        default: "77.237.232.66"
        description: "Contabo instance IP"
      contabo_datacenter:
        required: false
        type: string
        default: "European Union 2"
        description: "Contabo datacenter"
      contabo_region:
        required: false
        type: string
        default: "EU"
        description: "Contabo region"
      ssh_deploy:
        required: false
        type: boolean
        default: false
        description: "Enable SSH deployment"
      ssh_host:
        required: false
        type: string
        description: "SSH target host"
      ssh_user:
        required: false
        type: string
        description: "SSH username"
      ssh_port:
        required: false
        type: string
        default: "22"
        description: "SSH port"
      ssh_deploy_command:
        required: false
        type: string
        description: "Custom SSH deployment command"
      registry_server:
        required: false
        type: string
        default: docker.io
        description: "Container registry server (e.g., docker.io, gcr.io, quay.io)"
      registry_namespace:
        required: false
        type: string
        default: codevertex
        description: "Registry namespace/organization (e.g., codevertex, myorg)"
      docker_context:
        required: false
        type: string
        default: .
        description: "Docker build context path (relative to repository root)"
      dockerfile:
        required: false
        type: string
        default: Dockerfile
        description: "Path to Dockerfile (relative to docker_context)"
      image_repository:
        required: false
        type: string
        description: "Custom image repository (overrides registry_server/namespace/app_name)"
      deploy:
        required: false
        type: boolean
        default: false
        description: "Enable deployment phase (build, push, and deploy)"
      values_file_path:
        required: true
        type: string
        description: "Path to Helm values file in devops-k8s repository (e.g., apps/erp-api/values.yaml)"
      chart_repo_path:
        required: false
        type: string
        default: charts/app
        description: "Path to Helm chart in devops-k8s repository"
      namespace:
        required: false
        type: string
        default: default
        description: "Kubernetes namespace for deployment (must exist or be creatable)"
      # Git configuration for devops-k8s repo access
      git_user:
        required: false
        type: string
        default: "Titus Owuor"
        description: "Git commit author name for devops-k8s repository updates"
      git_email:
        required: false
        type: string
        default: "titusowuor30@gmail.com"
        description: "Git commit author email for devops-k8s repository updates"
      devops_repo:
        required: false
        type: string
        default: "Bengo-Hub/devops-k8s"
        description: "DevOps repository in format 'owner/repo' for Helm updates"
      # Database automation (optional)
      setup_databases:
        required: false
        type: boolean
        default: false
        description: "Enable automatic database setup (postgres, redis, mongo, mysql)"
      db_types:
        description: "Comma-separated list of databases to setup (postgres,redis,mongo,mysql)"
        required: false
        type: string
        default: "postgres,redis"
      env_secret_name:
        description: "Kubernetes Secret name to create/update with DB URLs"
        required: false
        type: string
        default: "app-env"
      provider:
        required: false
        type: string
        default: contabo
        description: "Cloud provider (contabo, aws, gcp, azure)"
      contabo_api:
        required: false
        type: boolean
        default: true
        description: "Enable Contabo API for instance management"
      contabo_instance_id:
        required: false
        type: string
        default: "202846760"
        description: "Contabo instance ID for API operations"
      contabo_ip:
        required: false
        type: string
        default: "77.237.232.66"
        description: "Contabo instance IP address"
      contabo_datacenter:
        required: false
        type: string
        default: "European Union 2"
        description: "Contabo datacenter location"
      contabo_region:
        required: false
        type: string
        default: "EU"
        description: "Contabo region (EU, US, etc.)"
      ssh_deploy:
        required: false
        type: boolean
        default: false
        description: "Enable SSH deployment to VPS"
      ssh_host:
        required: false
        type: string
        description: "SSH target host (IP or hostname)"
      ssh_user:
        required: false
        type: string
        description: "SSH username for deployment"
      ssh_port:
        required: false
        type: string
        default: "22"
        description: "SSH port (default: 22)"
      ssh_deploy_command:
        required: false
        type: string
        description: "Custom SSH deployment command"
    secrets:
      REGISTRY_USERNAME:
        required: false
      REGISTRY_PASSWORD:
        required: false
      KUBE_CONFIG:
        required: false
      SSH_PRIVATE_KEY:
        required: false
      DOCKER_SSH_KEY:
        required: false
      # Optional DB credentials (auto-generated if not provided)
      POSTGRES_PASSWORD:
        required: false
      REDIS_PASSWORD:
        required: false
      MONGO_PASSWORD:
        required: false
      MYSQL_PASSWORD:
        required: false
      CONTABO_CLIENT_ID:
        required: false
      CONTABO_CLIENT_SECRET:
        required: false
      CONTABO_API_USERNAME:
        required: false
      CONTABO_API_PASSWORD:
        required: false

jobs:
  build-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    secrets:
      REGISTRY_USERNAME: ${{ secrets.REGISTRY_USERNAME }}
      REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
      KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}
      DOCKER_SSH_KEY: ${{ secrets.DOCKER_SSH_KEY }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
      MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}
      MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
      CONTABO_CLIENT_ID: ${{ secrets.CONTABO_CLIENT_ID }}
      CONTABO_CLIENT_SECRET: ${{ secrets.CONTABO_CLIENT_SECRET }}
      CONTABO_API_USERNAME: ${{ secrets.CONTABO_API_USERNAME }}
      CONTABO_API_PASSWORD: ${{ secrets.CONTABO_API_PASSWORD }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Normalize inputs for both workflow_call and workflow_dispatch
        id: inputs
        run: |
          # Handle both workflow_call and workflow_dispatch inputs
          APP_NAME="${{ inputs.app_name || github.event.inputs.app_name }}"
          REGISTRY_SERVER="${{ inputs.registry_server || github.event.inputs.registry_server || 'docker.io' }}"
          REGISTRY_NAMESPACE="${{ inputs.registry_namespace || github.event.inputs.registry_namespace || 'codevertex' }}"
          DOCKER_CONTEXT="${{ inputs.docker_context || github.event.inputs.docker_context || '.' }}"
          DOCKERFILE="${{ inputs.dockerfile || github.event.inputs.dockerfile || 'Dockerfile' }}"
          IMAGE_REPOSITORY="${{ inputs.image_repository || github.event.inputs.image_repository || '' }}"
          DEPLOY="${{ inputs.deploy || github.event.inputs.deploy || false }}"
          VALUES_FILE_PATH="${{ inputs.values_file_path || github.event.inputs.values_file_path }}"
          CHART_REPO_PATH="${{ inputs.chart_repo_path || github.event.inputs.chart_repo_path || 'charts/app' }}"
          NAMESPACE="${{ inputs.namespace || github.event.inputs.namespace || 'default' }}"
          GIT_USER="${{ inputs.git_user || github.event.inputs.git_user || 'Titus Owuor' }}"
          GIT_EMAIL="${{ inputs.git_email || github.event.inputs.git_email || 'titusowuor30@gmail.com' }}"
          DEVOPS_REPO="${{ inputs.devops_repo || github.event.inputs.devops_repo || 'Bengo-Hub/devops-k8s' }}"
          SETUP_DATABASES="${{ inputs.setup_databases || github.event.inputs.setup_databases || false }}"
          DB_TYPES="${{ inputs.db_types || github.event.inputs.db_types || 'postgres,redis' }}"
          ENV_SECRET_NAME="${{ inputs.env_secret_name || github.event.inputs.env_secret_name || 'app-env' }}"
          PROVIDER="${{ inputs.provider || github.event.inputs.provider || 'contabo' }}"
          CONTABO_API="${{ inputs.contabo_api || github.event.inputs.contabo_api || true }}"
          CONTABO_INSTANCE_ID="${{ inputs.contabo_instance_id || github.event.inputs.contabo_instance_id || '202846760' }}"
          CONTABO_IP="${{ inputs.contabo_ip || github.event.inputs.contabo_ip || '77.237.232.66' }}"
          CONTABO_DATACENTER="${{ inputs.contabo_datacenter || github.event.inputs.contabo_datacenter || 'European Union 2' }}"
          CONTABO_REGION="${{ inputs.contabo_region || github.event.inputs.contabo_region || 'EU' }}"
          SSH_DEPLOY="${{ inputs.ssh_deploy || github.event.inputs.ssh_deploy || false }}"
          SSH_HOST="${{ inputs.ssh_host || github.event.inputs.ssh_host || '' }}"
          SSH_USER="${{ inputs.ssh_user || github.event.inputs.ssh_user || '' }}"
          SSH_PORT="${{ inputs.ssh_port || github.event.inputs.ssh_port || '22' }}"
          SSH_DEPLOY_COMMAND="${{ inputs.ssh_deploy_command || github.event.inputs.ssh_deploy_command || '' }}"

          # Generic branding inputs
          DEPLOYMENT_SUMMARY_TITLE="${{ inputs.deployment_summary_title || github.event.inputs.deployment_summary_title || 'Deployment Summary' }}"
          DEPLOYMENT_SUCCESS_MESSAGE="${{ inputs.deployment_success_message || github.event.inputs.deployment_success_message || 'Deployment completed! Application should be accessible via the URLs above.' }}"
          APPLICATION_DISPLAY_NAME="${{ inputs.application_display_name || github.event.inputs.application_display_name || '' }}"

          # Export all inputs for use in subsequent steps
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "registry_server=$REGISTRY_SERVER" >> $GITHUB_OUTPUT
          echo "registry_namespace=$REGISTRY_NAMESPACE" >> $GITHUB_OUTPUT
          echo "docker_context=$DOCKER_CONTEXT" >> $GITHUB_OUTPUT
          echo "dockerfile=$DOCKERFILE" >> $GITHUB_OUTPUT
          echo "image_repository=$IMAGE_REPOSITORY" >> $GITHUB_OUTPUT
          echo "deploy=$DEPLOY" >> $GITHUB_OUTPUT
          echo "values_file_path=$VALUES_FILE_PATH" >> $GITHUB_OUTPUT
          echo "chart_repo_path=$CHART_REPO_PATH" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "git_user=$GIT_USER" >> $GITHUB_OUTPUT
          echo "git_email=$GIT_EMAIL" >> $GITHUB_OUTPUT
          echo "devops_repo=$DEVOPS_REPO" >> $GITHUB_OUTPUT
          echo "setup_databases=$SETUP_DATABASES" >> $GITHUB_OUTPUT
          echo "db_types=$DB_TYPES" >> $GITHUB_OUTPUT
          echo "env_secret_name=$ENV_SECRET_NAME" >> $GITHUB_OUTPUT
          echo "provider=$PROVIDER" >> $GITHUB_OUTPUT
          echo "contabo_api=$CONTABO_API" >> $GITHUB_OUTPUT
          echo "contabo_instance_id=$CONTABO_INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "contabo_ip=$CONTABO_IP" >> $GITHUB_OUTPUT
          echo "contabo_datacenter=$CONTABO_DATACENTER" >> $GITHUB_OUTPUT
          echo "contabo_region=$CONTABO_REGION" >> $GITHUB_OUTPUT
          echo "ssh_deploy=$SSH_DEPLOY" >> $GITHUB_OUTPUT
          echo "ssh_host=$SSH_HOST" >> $GITHUB_OUTPUT
          echo "ssh_user=$SSH_USER" >> $GITHUB_OUTPUT
          echo "ssh_port=$SSH_PORT" >> $GITHUB_OUTPUT
          echo "ssh_deploy_command=$SSH_DEPLOY_COMMAND" >> $GITHUB_OUTPUT
          echo "deployment_summary_title=$DEPLOYMENT_SUMMARY_TITLE" >> $GITHUB_OUTPUT
          echo "deployment_success_message=$DEPLOYMENT_SUCCESS_MESSAGE" >> $GITHUB_OUTPUT
          echo "application_display_name=$APPLICATION_DISPLAY_NAME" >> $GITHUB_OUTPUT

      - name: Configure SSH for build secrets (optional)
        env:
          SSH_PRIV: ${{ secrets.SSH_PRIVATE_KEY }}
          DOCKER_SSH_KEY_B64: ${{ secrets.DOCKER_SSH_KEY }}
        run: |
          mkdir -p -m 0700 $HOME/.ssh

          # Check if SSH keys are available
          USE_SSH=false
          if [ -n "${DOCKER_SSH_KEY_B64:-}" ] && [ "$DOCKER_SSH_KEY_B64" != "" ]; then
            echo "Found DOCKER_SSH_KEY, will use SSH for builds"
            USE_SSH=true
          elif [ -n "${SSH_PRIV:-}" ] && [ "$SSH_PRIV" != "" ]; then
            echo "Found SSH_PRIVATE_KEY, will use SSH for builds"
            USE_SSH=true
          fi

          if [ "$USE_SSH" = "true" ]; then
            if [ -n "${DOCKER_SSH_KEY_B64:-}" ] && [ "$DOCKER_SSH_KEY_B64" != "" ]; then
              echo "Loading DOCKER_SSH_KEY"
              echo "$DOCKER_SSH_KEY_B64" | base64 -d > $HOME/.ssh/id_rsa
            else
              echo "Loading SSH_PRIVATE_KEY as fallback"
              printf "%s" "$SSH_PRIV" > $HOME/.ssh/id_rsa
            fi
            chmod 0600 $HOME/.ssh/id_rsa
            ssh-keyscan github.com >> $HOME/.ssh/known_hosts 2>/dev/null || true
            eval "$(ssh-agent)"
            # Add SSH key with passphrase "codevertex" for automated deployments
            echo "codevertex" | SSH_ASKPASS=/bin/echo ssh-add $HOME/.ssh/id_rsa 2>/dev/null || {
              echo "❌ Failed to add SSH key to agent - passphrase may be incorrect"
              exit 1
            }
            echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
            echo "SSH configured successfully"
          else
            echo "No SSH keys found, will build without SSH"
            echo "SSH_AUTH_SOCK=" >> $GITHUB_ENV
          fi

      - name: Determine image repository
        id: img
        env:
          REG_SVR: ${{ inputs.registry_server }}
          REG_NS: ${{ inputs.registry_namespace }}
        run: |
          if [ -n "${{ inputs.image_repository }}" ]; then
            echo "repo=${{ inputs.image_repository }}" >> $GITHUB_OUTPUT
          else
            echo "repo=${REG_SVR}/${REG_NS}/${{ inputs.app_name }}" >> $GITHUB_OUTPUT
          fi

      - name: Log in to registry (optional)
        if: ${{ secrets.REGISTRY_USERNAME != '' && secrets.REGISTRY_PASSWORD != '' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.registry_server }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Derive short SHA
        id: vars
        run: echo "short_sha=${GITHUB_SHA::8}" >> $GITHUB_OUTPUT

      - name: Install DevOps Tools
        uses: ./.github/actions/install-devops-tools

      - name: Trivy FS scan
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          scan-ref: .
          exit-code: '0'

      - name: Build image (with SSH)
        if: ${{ env.SSH_AUTH_SOCK != '' && env.SSH_AUTH_SOCK != null }}
        run: |
          echo "🔑 Building with SSH support"
          echo "📦 Image: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          DOCKER_BUILDKIT=1 docker build "${{ inputs.docker_context }}" \
            -f "${{ inputs.dockerfile }}" \
            -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}" \
            --ssh default="$SSH_AUTH_SOCK"

      - name: Build image (no SSH)
        if: ${{ env.SSH_AUTH_SOCK == '' || env.SSH_AUTH_SOCK == null }}
        run: |
          echo "🚫 Building without SSH (no keys configured)"
          echo "📦 Image: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
          DOCKER_BUILDKIT=1 docker build "${{ inputs.docker_context }}" \
            -f "${{ inputs.dockerfile }}" \
            -t "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Trivy Image scan
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: ${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}
          exit-code: '0'

      - name: Push image
        if: ${{ inputs.deploy }}
        run: docker push "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Setup databases (optional)
        if: ${{ inputs.deploy && inputs.setup_databases }}
        timeout-minutes: 10
        continue-on-error: true
        env:
          NS: ${{ inputs.namespace }}
          DB_TYPES: ${{ inputs.db_types }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
          MONGO_PASSWORD: ${{ secrets.MONGO_PASSWORD }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          set -e
          echo "Setting up databases in namespace ${NS}: ${DB_TYPES}"
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"

          # Tools
          sudo apt-get update -y && sudo apt-get install -y jq curl

          # Generate passwords if not provided
          gen_pwd() { openssl rand -hex 16; }
          : "${POSTGRES_PASSWORD:=$(gen_pwd)}"; : "${REDIS_PASSWORD:=$(gen_pwd)}"; : "${MONGO_PASSWORD:=$(gen_pwd)}"; : "${MYSQL_PASSWORD:=$(gen_pwd)}"

          echo "::group::Install Helm repos"
          helm repo add bitnami https://charts.bitnami.com/bitnami >/dev/null 2>&1 || true
          helm repo update >/dev/null 2>&1 || true
          echo "::endgroup::"

          # Parse db types
          SAVEIFS=$IFS; IFS=','; set -f; types=($DB_TYPES); IFS=$SAVEIFS; set +f

          DB_SETUP_SUCCESS=0
          DB_SETUP_TOTAL=${#types[@]}

          for db in "${types[@]}"; do
            db=$(echo "$db" | xargs)
            echo "::group::Installing $db"

            case "$db" in
              postgres)
                echo "Installing PostgreSQL..."
                if helm upgrade --install postgresql bitnami/postgresql -n "$NS" \
                  --set global.postgresql.auth.postgresPassword="$POSTGRES_PASSWORD" \
                  --set global.postgresql.auth.database="appdb" \
                  --wait --timeout=300s; then
                  echo "✅ PostgreSQL installed successfully"
                  export POSTGRES_URL="postgresql://postgres:${POSTGRES_PASSWORD}@postgresql.${NS}.svc.cluster.local:5432/appdb"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "❌ Failed to install PostgreSQL"
                fi
                ;;
              redis)
                echo "Installing Redis..."
                if helm upgrade --install redis bitnami/redis -n "$NS" \
                  --set global.redis.password="$REDIS_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "✅ Redis installed successfully"
                  export REDIS_URL="redis://:${REDIS_PASSWORD}@redis-master.${NS}.svc.cluster.local:6379/0"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "❌ Failed to install Redis"
                fi
                ;;
              mongo|mongodb)
                echo "Installing MongoDB..."
                if helm upgrade --install mongodb bitnami/mongodb -n "$NS" \
                  --set auth.rootPassword="$MONGO_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "✅ MongoDB installed successfully"
                  export MONGO_URL="mongodb://root:${MONGO_PASSWORD}@mongodb.${NS}.svc.cluster.local:27017/?authSource=admin"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "❌ Failed to install MongoDB"
                fi
                ;;
              mysql)
                echo "Installing MySQL..."
                if helm upgrade --install mysql bitnami/mysql -n "$NS" \
                  --set auth.rootPassword="$MYSQL_PASSWORD" \
                  --wait --timeout=300s; then
                  echo "✅ MySQL installed successfully"
                  export MYSQL_URL="mysql://root:${MYSQL_PASSWORD}@mysql.${NS}.svc.cluster.local:3306/appdb"
                  DB_SETUP_SUCCESS=$((DB_SETUP_SUCCESS + 1))
                else
                  echo "❌ Failed to install MySQL"
                fi
                ;;
              *)
                echo "⚠️ Unknown database type: $db"
                ;;
            esac
            echo "::endgroup::"
          done

          echo "📊 Database setup summary: $DB_SETUP_SUCCESS/$DB_SETUP_TOTAL successful"

          # Create/update environment secret with database URLs
          echo "::group::Creating environment secret"
          LITS=""
          [ -n "$POSTGRES_URL" ] && LITS="$LITS --from-literal=DATABASE_URL=$POSTGRES_URL"
          [ -n "$REDIS_URL" ] && LITS="$LITS --from-literal=REDIS_URL=$REDIS_URL --from-literal=CELERY_BROKER_URL=$REDIS_URL --from-literal=CELERY_RESULT_BACKEND=$REDIS_URL"
          [ -n "$MONGO_URL" ] && LITS="$LITS --from-literal=MONGO_URL=$MONGO_URL"
          [ -n "$MYSQL_URL" ] && LITS="$LITS --from-literal=MYSQL_URL=$MYSQL_URL"

          if [ -n "$LITS" ]; then
            if kubectl -n "$NS" create secret generic "${{ inputs.env_secret_name }}" $LITS --dry-run=client -o yaml | kubectl apply -f -; then
              echo "✅ Environment secret created/updated successfully"
            else
              echo "❌ Failed to create/update environment secret"
            fi
          else
            echo "ℹ️ No database URLs were generated; skipping secret creation"
          fi
          echo "::endgroup::"

      - name: Contabo API bootstrap (ensure instance ready)
        id: contabo_bootstrap
        if: ${{ inputs.deploy && inputs.provider == 'contabo' && inputs.contabo_api }}
        env:
          CLIENT_ID: ${{ secrets.CONTABO_CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CONTABO_CLIENT_SECRET }}
          API_USER: ${{ secrets.CONTABO_API_USERNAME }}
          API_PASS: ${{ secrets.CONTABO_API_PASSWORD }}
          INSTANCE_ID: ${{ inputs.contabo_instance_id }}
        run: |
          if [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ] || [ -z "$API_USER" ] || [ -z "$API_PASS" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Missing Contabo API credentials or instance id, will rely on SSH fallback if enabled"; exit 0; fi
          sudo apt-get update -y && sudo apt-get install -y jq curl
          TOKEN=$(curl -s -X POST https://auth.contabo.com/oauth2/token \
            -H 'Content-Type: application/x-www-form-urlencoded' \
            -d "grant_type=password&username=${API_USER}&password=${API_PASS}&client_id=${CLIENT_ID}&client_secret=${CLIENT_SECRET}&scope=openid")
          ACCESS_TOKEN=$(echo "$TOKEN" | jq -r '.access_token')
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then echo "Failed to acquire Contabo token"; exit 0; fi
          INFO=$(curl -s -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID)
          STATUS=$(echo "$INFO" | jq -r '.status // .data[0].status')
          IP=$(echo "$INFO" | jq -r '.publicIpConfig.ip || .data[0].publicIpConfig.ip')
          echo "Contabo instance status: $STATUS, ip: $IP"
          echo "contabo_ip=$IP" >> $GITHUB_OUTPUT
          # Optionally ensure instance is powered on
          if [ "$STATUS" != "running" ] && [ "$STATUS" != "ACTIVE" ]; then
            curl -s -X POST -H "Authorization: Bearer $ACCESS_TOKEN" https://api.contabo.com/v1/compute/instances/$INSTANCE_ID/start || true
          fi

      - name: Update values in devops-k8s
        if: ${{ inputs.deploy }}
        timeout-minutes: 5
        env:
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
          VALUES_PATH: ${{ inputs.values_file_path }}
          IMAGE_REPO: ${{ steps.img.outputs.repo }}
          DEVOPS_REPO: ${{ inputs.devops_repo }}
          GIT_USER: ${{ inputs.git_user }}
          GIT_EMAIL: ${{ inputs.git_email }}
        run: |
          # Ensure SSH is configured for git operations
          if [ -n "${SSH_AUTH_SOCK:-}" ] && [ "$SSH_AUTH_SOCK" != "" ]; then
            echo "🔑 Using SSH for git operations"
            export SSH_AUTH_SOCK="$SSH_AUTH_SOCK"

            # Create SSH config file for reliable git operations
            mkdir -p ~/.ssh
            cat > ~/.ssh/config << 'EOF'
            Host github.com
                HostName github.com
                User git
                IdentitiesOnly yes
                StrictHostKeyChecking no
            EOF
            chmod 600 ~/.ssh/config

            # Set SSH key path for git operations
            if [ -n "${DOCKER_SSH_KEY_B64:-}" ]; then
              echo "Using DOCKER_SSH_KEY for git operations"
              echo "$DOCKER_SSH_KEY_B64" | base64 -d > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            elif [ -n "${SSH_PRIV:-}" ]; then
              echo "Using SSH_PRIVATE_KEY for git operations"
              printf "%s" "$SSH_PRIV" > ~/.ssh/id_rsa
              chmod 600 ~/.ssh/id_rsa
              echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
            fi

            echo "✅ SSH configured for git operations"
          else
            echo "⚠️ SSH not configured, git operations may fail"
          fi

          git config user.name "$GIT_USER"
          git config user.email "$GIT_EMAIL"

          # Retry git operations with exponential backoff
          max_retries=3
          for ((i=1; i<=max_retries; i++)); do
            echo "🔄 Git operation attempt $i/$max_retries"

            if git pull --rebase; then
              echo "✅ Git pull successful"
              break
            else
              echo "❌ Git pull failed (attempt $i/$max_retries)"
              if [ $i -eq $max_retries ]; then
                echo "💥 All git pull attempts failed, continuing with local repo"
                break
              fi
              sleep $((2 ** (i-1)))  # Exponential backoff: 1s, 2s, 4s
            fi
          done

          # Update Helm values
          if [ -f "$VALUES_PATH" ]; then
            echo "📝 Updating Helm values: $VALUES_PATH"
            yq -yi ".image.repository = \"${IMAGE_REPO}\" | .image.tag = \"${SHORT_SHA}\"" "${VALUES_PATH}"

            if [ $? -eq 0 ]; then
              echo "✅ Helm values updated successfully"

              # Check if there are changes to commit
              if git diff --quiet HEAD "${VALUES_PATH}"; then
                echo "ℹ️ No changes to commit"
              else
                echo "💾 Committing changes"
                git add "${VALUES_PATH}"

                # Retry git commit
                if git commit -m "${{ inputs.app_name }}:${SHORT_SHA} released"; then
                  echo "✅ Changes committed"

                  # Retry git push with exponential backoff
                  push_max_retries=3
                  for ((j=1; j<=push_max_retries; j++)); do
                    echo "🔄 Git push attempt $j/$push_max_retries"
                    if git push; then
                      echo "✅ Git push successful"
                      break
                    else
                      echo "❌ Git push failed (attempt $j/$push_max_retries)"
                      if [ $j -eq $push_max_retries ]; then
                        echo "💥 All git push attempts failed"
                        echo "⚠️ Deployment will continue despite git push failure"
                      fi
                      sleep $((2 ** (j-1)))
                    fi
                  done
                else
                  echo "❌ Git commit failed"
                fi
              fi
            else
              echo "❌ Failed to update Helm values"
            fi
          else
            echo "⚠️ Helm values file not found: $VALUES_PATH"
          fi

      - name: Apply kube secrets (optional)
        if: ${{ inputs.deploy && secrets.KUBE_CONFIG != '' }}
        env:
          NS: ${{ inputs.namespace }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "${NS}" >/dev/null 2>&1 || kubectl create ns "${NS}"
          if [ -f kubeSecrets/devENV.yaml ]; then
            kubectl apply -f kubeSecrets/devENV.yaml || true
          fi

      - name: Ensure default JWT secret (when KUBE_CONFIG provided)
        if: ${{ inputs.deploy && secrets.KUBE_CONFIG != '' }}
        env:
          NS: ${{ inputs.namespace }}
          SECRET_NAME: ${{ inputs.env_secret_name }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          set -e
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          kubectl get ns "$NS" >/dev/null 2>&1 || kubectl create ns "$NS"
          JWT=$(openssl rand -hex 32)
          if kubectl -n "$NS" get secret "$SECRET_NAME" >/dev/null 2>&1; then
            # Patch only if key missing
            if ! kubectl -n "$NS" get secret "$SECRET_NAME" -o jsonpath='{.data.JWT_SECRET}' >/dev/null 2>&1; then
              kubectl -n "$NS" patch secret "$SECRET_NAME" -p "{\"stringData\":{\"JWT_SECRET\":\"$JWT\"}}"
            fi
          else
            kubectl -n "$NS" create secret generic "$SECRET_NAME" --from-literal=JWT_SECRET="$JWT"
          fi

      - name: Run database migrations (Django apps)
        if: ${{ inputs.deploy && secrets.KUBE_CONFIG != '' && inputs.app_name == 'erp-api' }}
        env:
          NS: ${{ inputs.namespace }}
          IMAGE_REPO: ${{ steps.img.outputs.repo }}
          SHORT_SHA: ${{ steps.vars.outputs.short_sha }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          echo "::group::Running database migrations"
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          
          # Create migration job
          cat > /tmp/migrate-job.yaml <<EOF
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: erp-migrate-${{ steps.vars.outputs.short_sha }}
            namespace: ${NS}
          spec:
            ttlSecondsAfterFinished: 600
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: migrate
                  image: ${IMAGE_REPO}:${SHORT_SHA}
                  command: ["python", "manage.py", "migrate"]
                  envFrom:
                  - secretRef:
                      name: ${{ inputs.env_secret_name }}
          EOF
          
          kubectl apply -f /tmp/migrate-job.yaml
          kubectl wait --for=condition=complete job/erp-migrate-${{ steps.vars.outputs.short_sha }} -n ${NS} --timeout=300s || {
            echo "Migration job logs:"
            kubectl logs job/erp-migrate-${{ steps.vars.outputs.short_sha }} -n ${NS} || true
            exit 1
          }
          echo "✅ Database migrations completed"
          echo "::endgroup::"

      - name: SSH deploy to VPS (optional)
        if: ${{ inputs.ssh_deploy || (inputs.provider == 'contabo' && inputs.contabo_api && steps.vars.outputs.short_sha != '' ) }}
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ inputs.ssh_host || inputs.contabo_ip || steps.contabo_bootstrap.outputs.contabo_ip }}
          username: ${{ inputs.ssh_user }}
          port: ${{ inputs.ssh_port }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            echo "Logging into registry"
            echo '${{ secrets.REGISTRY_PASSWORD }}' | docker login ${{ inputs.registry_server }} -u '${{ secrets.REGISTRY_USERNAME }}' --password-stdin || true
            echo "Pulling image"
            docker pull "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"
            echo "Restarting container"
            docker rm -f ${{ inputs.app_name }} || true
            docker run -d --restart always --name ${{ inputs.app_name }} -p 0.0.0.0:80:80 "${{ steps.img.outputs.repo }}:${{ steps.vars.outputs.short_sha }}"

      - name: Get service URLs
        id: service_urls
        if: ${{ inputs.deploy && secrets.KUBE_CONFIG != '' }}
        env:
          NS: ${{ inputs.namespace }}
          APP_NAME: ${{ inputs.app_name }}
          KUBE_CONFIG_B64: ${{ secrets.KUBE_CONFIG }}
        run: |
          mkdir -p ~/.kube
          echo "$KUBE_CONFIG_B64" | base64 -d > ~/.kube/config
          
          # Wait for services to be ready and discover URLs
          echo "🔍 Discovering service URLs..."

          urls=""
          max_wait_time=300  # 5 minutes timeout
          wait_interval=15   # Check every 15 seconds
          elapsed_time=0

          while [[ $elapsed_time -lt $max_wait_time ]]; do
            echo "⏳ Waiting for services to be ready... (${elapsed_time}s/${max_wait_time}s)"

            # Get ingress URLs for the application
            if kubectl get ingress -n "$NS" >/dev/null 2>&1; then
              while IFS= read -r ingress; do
                if [[ -n "$ingress" ]]; then
                  # Extract host from ingress
                  host=$(kubectl get ingress "$ingress" -n "$NS" -o jsonpath='{.spec.rules[0].host}' 2>/dev/null)

                  if [[ -n "$host" ]]; then
                    # Determine protocol (default to http, but check for TLS)
                    protocol="http"
                    if kubectl get ingress "$ingress" -n "$NS" -o jsonpath='{.spec.tls}' 2>/dev/null | grep -q "hosts"; then
                      protocol="https"
                    fi

                    urls="${urls}${protocol}://${host}\n"
                    echo "✅ Found ingress URL: ${protocol}://${host}"
                  fi
                fi
              done < <(kubectl get ingress -n "$NS" -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)
            fi

            # If no ingress URLs found, try to get service URLs
            if [[ -z "$urls" ]]; then
              if kubectl get svc "$APP_NAME" -n "$NS" >/dev/null 2>&1; then
                service_port=$(kubectl get svc "$APP_NAME" -n "$NS" -o jsonpath='{.spec.ports[0].port}' 2>/dev/null)

                if [[ -n "$service_port" ]]; then
                  # Check if service is ready (has endpoints)
                  if kubectl get endpoints "$APP_NAME" -n "$NS" -o jsonpath='{.subsets[*].addresses}' 2>/dev/null | grep -q "ip"; then
                    urls="http://${APP_NAME}.${NS}.svc.cluster.local:${service_port}\n"
                    urls="${urls}(Cluster internal URL - configure ingress for external access)"
                    echo "✅ Found service URL: http://${APP_NAME}.${NS}.svc.cluster.local:${service_port}"
                  fi
                fi
              fi
            fi

            # If we found URLs, break out of the waiting loop
            if [[ -n "$urls" ]]; then
              echo "🎉 Service URLs discovered successfully!"
              break
            fi

            # Wait before next check
            sleep $wait_interval
            elapsed_time=$((elapsed_time + wait_interval))
          done

          # Final status report
          if [[ -n "$urls" ]]; then
            echo "✅ Service URLs discovered after ${elapsed_time}s:"
            echo -e "$urls"
          else
            echo "⚠️ No service URLs found after ${max_wait_time}s timeout"
            echo "🔧 Services may still be starting up - check ArgoCD sync status"
            urls="⏳ Services still starting up...\nCheck ArgoCD for sync status"
          fi

          echo "service_urls<<EOF" >> $GITHUB_OUTPUT
          echo -e "$urls" | sed '/^$/d' | head -5 >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Deployment Summary
        if: ${{ inputs.deploy }}
        run: |
          # Determine display name for the application
          APP_DISPLAY_NAME="${{ inputs.application_display_name || inputs.app_name }}"

          echo "🚀 === ${{ inputs.deployment_summary_title }} ===" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ✅ Deployment Completed Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Application Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Application:** $APP_DISPLAY_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace:** ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ steps.vars.outputs.short_sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry:** ${{ steps.img.outputs.repo }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Display service URLs if available
          if [[ -n "${{ steps.service_urls.outputs.service_urls }}" ]]; then
            echo "### 🌐 Service URLs" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.service_urls.outputs.service_urls }}" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          else
            echo "### 🌐 Service URLs" >> $GITHUB_STEP_SUMMARY
            echo "⏳ Services are still starting up. Check ArgoCD sync status for external URLs." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Database information if setup was enabled
          if [[ "${{ inputs.setup_databases }}" == "true" ]]; then
            echo "### 🗄️ Database Setup" >> $GITHUB_STEP_SUMMARY
            echo "- **Databases:** ${{ inputs.db_types }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Secret:** ${{ inputs.env_secret_name }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Namespace:** ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "### 📋 Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. **Verify ArgoCD Sync:** Check that ArgoCD has synced the new image tag" >> $GITHUB_STEP_SUMMARY
          echo "2. **Test Application:** Access the service URLs listed above" >> $GITHUB_STEP_SUMMARY
          echo "3. **Monitor Logs:** Check application and database logs for any issues" >> $GITHUB_STEP_SUMMARY
          echo "4. **SSL Certificate:** Configure ingress with SSL certificate for HTTPS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### 🔧 Useful Commands" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Check ArgoCD sync status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get applications -n argocd" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check application logs" >> $GITHUB_STEP_SUMMARY
          echo "kubectl logs -l app=${{ inputs.app_name }} -n ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Check service status" >> $GITHUB_STEP_SUMMARY
          echo "kubectl get pods,svc,ingress -l app=${{ inputs.app_name }} -n ${{ inputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "🎉 **${{ inputs.deployment_success_message }}**" >> $GITHUB_STEP_SUMMARY
